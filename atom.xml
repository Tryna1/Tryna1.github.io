<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US">
  <id>https://vuepress-theme-hope-demo.mrhope.site/</id>
  <title>Theme Demo</title>
  <subtitle>A demo for vuepress-theme-hope</subtitle>
  <author>
    <name>Mr.Hope</name>
  </author>
  <updated>2022-02-21T13:43:47.492Z</updated>
  <generator>@mr-hope/vuepress-plugin-feed</generator>
  <link rel="self" href="https://vuepress-theme-hope-demo.mrhope.site/atom.xml"/>
  <link rel="alternate" href="https://vuepress-theme-hope-demo.mrhope.site/"/>
  <contributor>
    <name>Tryna</name>
  </contributor>
  <contributor>
    <name>Mr.Hope</name>
  </contributor>
  <entry>
    <title type="html">Java 笔记</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/Java%E5%9F%BA%E7%A1%80/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/Java%E5%9F%BA%E7%A1%80/"/>
    <updated>2022-02-21T13:44:21.558Z</updated>
    <content type="html"><![CDATA[<h2 id="参考"> 参考</h2>
<ul>
<li>
<p><a href="https://javaguide.cn/" target="_blank" rel="noopener noreferrer">JavaGuide</a></p>
</li>
<li>
<p><a href="https://www.r2coding.com/#/" target="_blank" rel="noopener noreferrer">Road 2 Coding</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>Tryna</name>
    </author>
    <contributor>
      <name>Tryna</name>
    </contributor>
    <rights>Copyright by Tryna</rights>
  </entry>
  <entry>
    <title type="html">基本概念与常识</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/"/>
    <updated>2022-02-21T13:44:21.573Z</updated>
    <content type="html"><![CDATA[<h2 id="java语言的特点"> Java语言的特点</h2>
<ol>
<li>简单易学</li>
<li>面向对象（面向对象的三个基本特征：封装、继承、多态）</li>
<li>平台无关性——平台无关性就是一种语言在计算机上的运行不受平台的约束，一次编译，到处执行（Write Once ,Run Anywhere）</li>
<li>支持多线程</li>
<li>可靠性</li>
<li>安全性</li>
<li>支持网络编程并且很方便（Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）</li>
<li>编译与解释并存——高级编程语言按照程序的执行方式分为编译型和解释型两种。Java 语言既具有编译型语言的特征，也具有解释型语言的特征。</li>
</ol>
<h2 id="jvm-jdk-jre"> JVM JDK JRE</h2>
<p><strong>JVM:</strong> Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>
<p><strong>JDK:</strong> Java开发工具，JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>
<p><strong>JRE:</strong> JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>
<h2 id="什么是字节码-采用字节码的好处是什么"> 什么是字节码?采用字节码的好处是什么?</h2>
<p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。
Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
<p><strong>Java 程序从源代码到运行的过程如下图所示：</strong>
<img src="https://javaguide.cn/assets/img/java程序转变为机器代码的过程.3dbbbc5a.png" alt="" loading="lazy"></p>
<p>我自己的理解是Java源文件经过编译器的编译之后形成后缀为.class的字节码，然后由JVM类加载器加载字节码文件，然后由解释器逐行解释执行，因为有些代码和方法经常被调用，所以引进了JIT（just-in-time compilation）编译器，JIT完成第一次编译后，会将字节码对应的机器码保存下来，下次可以直接使用。解释完毕之后就生成了机器码，可以在不同操作系统的计算机上运行。</p>
<h2 id="为什么说-java-语言-编译与解释并存"> 为什么说 Java 语言“编译与解释并存”？</h2>
<p>其实学到这里，这个问题我心中已经有答案了，因为觉得Guide哥整理的比较好，还是把这块放上来了。</p>
<p>我们可以将高级编程语言按照程序的执行方式分为两种：</p>
<ul>
<li><strong>编译型：</strong> 编译型语言会通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</li>
<li><strong>解释型：</strong> 解释型语言会通过解释器一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</li>
</ul>
<p><img src="https://javaguide.cn/assets/img/编译型语言和解释型语言.5a6e82b7.png" alt="" loading="lazy"></p>
<p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。</p>
<h2 id="java和c-的区别"> Java和C++的区别</h2>
<ul>
<li>都是面向对象的语言，都支持继承、封装、多态</li>
<li>Java不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承</li>
<li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存</li>
<li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）</li>
</ul>
]]></content>
    <author>
      <name>Tryna</name>
    </author>
    <contributor>
      <name>Tryna</name>
    </contributor>
    <rights>Copyright by Tryna</rights>
  </entry>
  <entry>
    <title type="html">数据类型</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <updated>2022-02-21T13:44:21.673Z</updated>
    <content type="html"><![CDATA[<h2 id="数据类型"> 数据类型</h2>
<p>在Java中，数据类型只有<code>四类八种</code></p>
<ul>
<li>整数型：byte、short、int、long</li>
<li>浮点型：float、double</li>
<li>字符型：char</li>
<li>布尔型：boolean</li>
</ul>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>内存</th>
<th>最小值</th>
<th>最大值</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>8位</td>
<td>-128</td>
<td>127</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>16位</td>
<td><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span>−</span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>15</span></span></span></span></span></span></span></span></span></span></span></span></td>
<td><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>15</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>32位</td>
<td><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span>−</span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span></span></span></span></td>
<td><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>64位</td>
<td><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span>−</span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>63</span></span></span></span></span></span></span></span></span></span></span></span></td>
<td><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>63</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>32位</td>
<td>IEEE754</td>
<td>IEEE754</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>64位</td>
<td>IEEE754</td>
<td>IEEE754</td>
<td>0.0d</td>
</tr>
<tr>
<td>char</td>
<td>16位</td>
<td>Unicode 0</td>
<td>Unicode <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>16</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></td>
<td>\u0000</td>
</tr>
<tr>
<td>boolean</td>
<td>8位</td>
<td>-</td>
<td>-</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong> Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <code>L</code>，否则将作为整型解析。</p>
<h2 id="命名规范"> 命名规范</h2>
<ul>
<li>类名：对于所有的类来说，首字母应该大写，例如<code>MyFirstClass</code></li>
<li>包名：包名应该尽量保证小写，例如<code>my.first.package</code></li>
<li>方法名：方法名首字母需要小写，后面每个单词字母都需要大写，例如<code>myFirstMethod()</code></li>
</ul>
<h2 id="运算符"> 运算符</h2>
<ul>
<li><strong>赋值运算符：</strong> 使用<code>=</code>来表示，意思为将等号右边的值赋值给等号左边。</li>
<li><strong>算术运算符：</strong> <code>+ - * / %</code></li>
<li><strong>自增、自减运算符：</strong></li>
</ul>
<div><pre><code><span>int</span> a <span>=</span> <span>5</span><span>;</span>
b <span>=</span> <span>++</span>a<span>;</span>
c <span>=</span> a<span>++</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>注意先运算还是先自增即可。</p>
<ul>
<li><strong>比较运算符：</strong> <code>&gt; &lt; &gt;= &lt;= == !=</code></li>
<li><strong>逻辑运算符：</strong></li>
</ul>
<p><img src="http://blog.tryna.top/img/2022-01-11-16-26-22.png" alt="" loading="lazy"></p>
<ul>
<li>
<p><strong>按位运算符：</strong> 按位运算符用来操作整数基本类型中的每个比特位，也就是二进制位，按位操作符会对两个参数中对应的位执行布尔代数运算，并最终生成一个结果。</p>
<ul>
<li>&amp;（按位与）两个操作数中位都为1，结果才为1，否则结果为0</li>
<li>|（按位或）两个操作数中有一位为1，结果为1，否则结果为0</li>
<li>~（按位非）如果位为0，结果为1，如果位为1，结果为0。（数值加1，符号取反）eg: ~4 = -5</li>
<li>^（按位异或）两个操作数的位中相同则结果为0，不同则为1</li>
</ul>
</li>
<li>
<p><strong>移位运算符：</strong> 移位运算符用来将操作数向某个方向移动指定的二进制位数</p>
<ul>
<li>右移运算符<code>&gt;&gt;</code> eg: <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6835em;vertical-align:-0.0391em;"></span><span>8</span><span style="margin-right:0.2778em;"></span><span>&gt;&gt;</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6444em;"></span><span>4</span></span></span></span></li>
<li>左移运算符<code>&lt;&lt;</code> eg: <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6835em;vertical-align:-0.0391em;"></span><span>9</span><span style="margin-right:0.2778em;"></span><span>&lt;&lt;</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6444em;"></span><span>2</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6444em;"></span><span>36</span></span></span></span></li>
</ul>
</li>
<li>
<p><strong>三元运算符：</strong> 三元运算符是类似<code>if...else...</code>这种的操作符，语法为<code>条件表达式？表达式1：表达式2</code>。问号前的位置是判断的条件，结果为布尔类型，为真时调用表达式1，否则调用表达式2。</p>
</li>
</ul>
<h2 id="java执行控制流程"> Java执行控制流程</h2>
<ul>
<li><strong>条件语句：</strong> <code>if语句</code>，<code>if...else语句</code>，<code>if...else if多支语句</code>，<code>switch语句</code></li>
<li><strong>循环语句：</strong> <code>while语句</code>，<code>do...while语句</code>，<code>for循环语句</code>
<ul>
<li><strong>for-each：</strong> 在Java JDK 1.5中还引入了一种更加简洁、方便对数组和集合进行遍历的方法。</li>
</ul>
</li>
</ul>
<div><pre><code><span>int</span> array<span>[</span><span>]</span> <span>=</span> <span>{</span><span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>}</span>

<span>for</span><span>(</span><span>int</span> arr <span>:</span> array<span>)</span> <span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li><strong>跳转语句：</strong>
<ul>
<li><strong>continue:</strong> 指跳出当前的这一次循环，继续下一次循环。</li>
<li><strong>break:</strong> 指跳出整个循环体，继续执行循环下面的语句。</li>
<li><strong>return:</strong> 用于跳出所在方法，结束该方法的运行。</li>
</ul>
</li>
</ul>
<h2 id="字符型常量与字符串常量的区别"> 字符型常量与字符串常量的区别？</h2>
<ol>
<li><strong>形式：</strong> 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符</li>
<li><strong>含义:</strong> 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</li>
<li><strong>占内存大小：</strong> 字符常量只占 2 个字节; 字符串常量占若干个字节 (注意： char 在 Java 中占两个字节)</li>
</ol>
<h2 id="可变长参数"> 可变长参数</h2>
<p>从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。</p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>method1</span><span>(</span><span>String</span><span>.</span><span>.</span><span>.</span> args<span>)</span> <span>{</span>
   <span>//......</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>method2</span><span>(</span><span>String</span> arg1<span>,</span> <span>String</span><span>.</span><span>.</span><span>.</span> args<span>)</span> <span>{</span>
   <span>//......</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</strong></p>
<p>答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</p>
<p>我们通过下面这个例子来证明一下。</p>
<div><pre><code><span>public</span> <span>class</span> <span>VariableLengthArgument</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>printVariable</span><span>(</span><span>String</span><span>.</span><span>.</span><span>.</span> args<span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>String</span> s <span>:</span> args<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>printVariable</span><span>(</span><span>String</span> arg1<span>,</span> <span>String</span> arg2<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arg1 <span>+</span> arg2<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>printVariable</span><span>(</span><span>"a"</span><span>,</span> <span>"b"</span><span>)</span><span>;</span>
        <span>printVariable</span><span>(</span><span>"a"</span><span>,</span> <span>"b"</span><span>,</span> <span>"c"</span><span>,</span> <span>"d"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>输出：</p>
<div><pre><code>ab
a
b
c
d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="注释"> 注释</h2>
<p>Java 中的注释有三种：</p>
<p><strong>1.单行注释</strong></p>
<p>以双斜杠<code>//</code>标识，只能注释一行内容，用在注释信息内容少的地方。</p>
<p><strong>2.多行注释</strong></p>
<p>包含在<code>/*</code>和<code>*/</code>之间，能注释很多行的内容。为了可读性比较好，一般首行和尾行不写注释信息（这样也比较美观好看）。</p>
<p><strong>3.文档注释</strong></p>
<p>包含在<code>/**</code>和<code>*/</code>之间，也能注释多行内容，一般用在类、方法和变量上面，用来描述其作用。注释后，鼠标放在类和变量上面会自动显示出我们注释的内容。</p>
<p><strong>代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。</strong></p>
<p><strong>若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。</strong></p>
<h2 id="标识符和关键字的区别是什么"> 标识符和关键字的区别是什么？</h2>
<p>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了标识符，简单来说，标识符就是一个名字。但是有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这种特殊的标识符就是关键字。因此，关键字是被赋予特殊含义的标识符。比如，在我们的日常生活中 ，“警察局”这个名字已经被赋予了特殊的含义，所以如果你开一家店，店的名字不能叫“警察局”，“警察局”就是我们日常生活中的关键字。</p>
<h2 id="java-中有哪些常见的关键字"> Java 中有哪些常见的关键字？</h2>
<table>
<thead>
<tr>
<th>分类</th>
<th>关键字</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>访问控制</td>
<td>private</td>
<td>public</td>
<td>protected</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>类，方法和变量修饰符</td>
<td>abstract</td>
<td>class</td>
<td>extends</td>
<td>final</td>
<td>implements</td>
<td>interface</td>
<td>native</td>
</tr>
<tr>
<td></td>
<td>new</td>
<td>static</td>
<td>strictfp</td>
<td>synchronized</td>
<td>transient</td>
<td>volatile</td>
<td></td>
</tr>
<tr>
<td>程序控制</td>
<td>break</td>
<td>continue</td>
<td>return</td>
<td>do</td>
<td>while</td>
<td>if</td>
<td>else</td>
</tr>
<tr>
<td></td>
<td>for</td>
<td>instanceof</td>
<td>switch</td>
<td>case</td>
<td>default</td>
<td></td>
<td></td>
</tr>
<tr>
<td>错误处理</td>
<td>try</td>
<td>catch</td>
<td>throw</td>
<td>throws</td>
<td>finally</td>
<td></td>
<td></td>
</tr>
<tr>
<td>包相关</td>
<td>import</td>
<td>package</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>基本类型</td>
<td>boolean</td>
<td>byte</td>
<td>short</td>
<td>int</td>
<td>long</td>
<td>float</td>
<td>double</td>
</tr>
<tr>
<td></td>
<td>char</td>
<td>null</td>
<td>false</td>
<td>true</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>变量引用</td>
<td>super</td>
<td>this</td>
<td>void</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>保留字</td>
<td>goto</td>
<td>const</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="方法"> 方法</h2>
<p>我们可以按照方法的返回值和参数类型将方法分为下面这几种：</p>
<p><strong>1.无参数无返回值的方法</strong>
<strong>2.有参数无返回值的方法</strong>
<strong>3.无参数有返回值的方法</strong>
<strong>4.有参数有返回值的方法</strong></p>
<p>静态方法为什么不能调用非静态成员?</p>
<p>这个需要结合 JVM 的相关知识，主要原因如下：
1.静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</p>
<p>2.在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</p>
<p>静态方法和实例方法有何不同？</p>
<p><strong>1、调用方式</strong></p>
<p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用<code>对象.方法名</code>的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p>
<p>不过，需要注意的是一般不建议使用 <code>对象.方法名</code> 的方式来调用静态方法。这种方式非常容易造成混淆，<strong>静态方法不属于类的某个对象而是属于这个类</strong>。</p>
<p>因此，一般建议使用 <code>类名.方法名</code> 的方式来调用静态方法。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Person</span> <span>{</span>
    <span>public</span> <span>void</span> <span>method</span><span>(</span><span>)</span> <span>{</span>
      <span>//......</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>staicMethod</span><span>(</span><span>)</span><span>{</span>
      <span>//......</span>
    <span>}</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Person</span> person <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>
        <span>// 调用实例方法</span>
        person<span>.</span><span>method</span><span>(</span><span>)</span><span>;</span>
        <span>// 调用静态方法</span>
        <span>Person</span><span>.</span><span>staicMethod</span><span>(</span><span>)</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><strong>2、访问类成员是否存在限制</strong></p>
<p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p>
<p>重载和重写的区别</p>
<blockquote>
<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理
重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>
</blockquote>
<p><strong>重载：</strong> 重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p>
<p><strong>重写：</strong> 重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<p>1.返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
2.如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。
3.构造方法无法被重写</p>
<p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody>
</table>
<h2 id="泛型"> 泛型</h2>
<p><strong>Java 泛型（generics）</strong> 是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<p>Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</p>
<p>泛型一般有三种使用方式: 泛型类、泛型接口、泛型方法。</p>
<p><strong>1.泛型类</strong></p>
<div><pre><code><span>//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span>
<span>//在实例化泛型类时，必须指定T的具体类型</span>
<span>public</span> <span>class</span> <span>Generic</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>
    <span>private</span> <span>T</span> key<span>;</span>
    <span>public</span> <span>Generic</span><span>(</span><span>T</span> key<span>)</span> <span>{</span>
        <span>this</span><span>.</span>key <span>=</span> key<span>;</span>
    <span>}</span>
    <span>public</span> <span>T</span> <span>getKey</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> key<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>如何实例化泛型类：</p>
<div><pre><code><span>Generic</span><span><span>&lt;</span><span>Integer</span><span>></span></span> genericInteger <span>=</span> <span>new</span> <span>Generic</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>123456</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>2.泛型接口</strong></p>
<div><pre><code><span>public</span> <span>interface</span> <span>Generator</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>
    <span>public</span> <span>T</span> <span>method</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>实现泛型接口，不指定类型：</p>
<div><pre><code><span>class</span> <span>GeneratorImpl</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>implements</span> <span>Generator</span><span><span>&lt;</span><span>T</span><span>></span></span><span>{</span>
    <span>@Override</span>
    <span>public</span> <span>T</span> <span>method</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>实现泛型接口，指定类型：</p>
<div><pre><code><span>class</span> <span>GeneratorImpl</span> <span>implements</span> <span>Generator</span><span><span>&lt;</span><span>String</span><span>></span></span><span>{</span>
    <span>@Override</span>
    <span>public</span> <span>String</span> <span>method</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>"hello"</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>3.泛型方法</strong></p>
<div><pre><code><span>public</span> <span>static</span> <span><span>&lt;</span><span>E</span><span>></span></span> <span>void</span> <span>printArray</span><span>(</span><span>E</span><span>[</span><span>]</span> inputArray<span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>E</span> element <span>:</span> inputArray<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>printf</span><span>(</span><span>"%s "</span><span>,</span> element<span>)</span><span>;</span>
    <span>}</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>使用：</p>
<div><pre><code><span>// 创建不同类型数组： Integer, Double 和 Character</span>
<span>Integer</span><span>[</span><span>]</span> intArray <span>=</span> <span>{</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span> <span>}</span><span>;</span>
<span>String</span><span>[</span><span>]</span> stringArray <span>=</span> <span>{</span> <span>"Hello"</span><span>,</span> <span>"World"</span> <span>}</span><span>;</span>
<span>printArray</span><span>(</span>intArray<span>)</span><span>;</span>
<span>printArray</span><span>(</span>stringArray<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>常用的通配符为  <strong>T，E，K，V，？</strong></p>
<ul>
<li>？ 表示不确定的 Java 类型</li>
<li>T (type) 表示具体的一个 Java 类型</li>
<li>K V (key value) 分别代表 Java 键值中的 Key Value</li>
<li>E (element) 代表 Element</li>
</ul>
<h2 id="和-equals-的区别"> == 和 equals() 的区别</h2>
<p><code>==</code> 对于基本类型和引用类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<p><code>equals()</code> 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> obj<span>)</span> <span>{</span>
     <span>return</span> <span>(</span><span>this</span> <span>==</span> obj<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>equals()</code> 方法存在两种使用情况：</p>
<ul>
<li><strong>类没有覆盖 equals()方法 ：</strong> 通过<code>equals()</code>比较该类的两个对象时，等价于通过<code>==</code>比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li><strong>类覆盖了 equals()方法 ：</strong> 一般我们都覆盖 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<div><pre><code><span>String</span> a <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"ab"</span><span>)</span><span>;</span> <span>// a 为一个引用</span>
<span>String</span> b <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"ab"</span><span>)</span><span>;</span> <span>// b为另一个引用,对象的内容一样</span>
<span>String</span> aa <span>=</span> <span>"ab"</span><span>;</span> <span>// 放在常量池中</span>
<span>String</span> bb <span>=</span> <span>"ab"</span><span>;</span> <span>// 从常量池中查找</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>aa <span>==</span> bb<span>)</span><span>;</span><span>// true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>==</span> b<span>)</span><span>;</span><span>// false</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>.</span><span>equals</span><span>(</span>b<span>)</span><span>)</span><span>;</span><span>// true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>42</span> <span>==</span> <span>42.0</span><span>)</span><span>;</span><span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>String</code> 中的 <code>equals()</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals()</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals()</code> 方法比较的是对象的值。</p>
<p><code>String</code>类<code>equals()</code>方法：</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> anObject<span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>this</span> <span>==</span> anObject<span>)</span> <span>{</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>anObject <span>instanceof</span> <span>String</span><span>)</span> <span>{</span>
        <span>String</span> anotherString <span>=</span> <span>(</span><span>String</span><span>)</span>anObject<span>;</span>
        <span>int</span> n <span>=</span> value<span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>n <span>==</span> anotherString<span>.</span>value<span>.</span>length<span>)</span> <span>{</span>
            <span>char</span> v1<span>[</span><span>]</span> <span>=</span> value<span>;</span>
            <span>char</span> v2<span>[</span><span>]</span> <span>=</span> anotherString<span>.</span>value<span>;</span>
            <span>int</span> i <span>=</span> <span>0</span><span>;</span>
            <span>while</span> <span>(</span>n<span>--</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span>v1<span>[</span>i<span>]</span> <span>!=</span> v2<span>[</span>i<span>]</span><span>)</span>
                    <span>return</span> <span>false</span><span>;</span>
                i<span>++</span><span>;</span>
            <span>}</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id="hashcode-与-equals"> hashCode() 与 equals()</h2>
<p><code>hashCode()</code> 的作用是获取哈希码（int 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p>
<p><code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</p>
<p>为什么要有 hashCode？</p>
<p>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode？</p>
<blockquote>
<p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p>
</blockquote>
<p>其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p>
<p><strong>那为什么 JDK 还要同时提供这两个方法呢？</strong></p>
<p>这是因为在一些容器（比如 HashMap、HashSet）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进HashSet的过程）！</p>
<p><strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong></p>
<p>这是因为两个对象的<code>hashCode</code>值相等并不代表两个对象就相等。</p>
<p><strong>那为什么两个对象有相同的 hashCode 值，它们也不一定是相等的？</strong></p>
<p>因为 hashCode() 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 hashCode )。</p>
<p>总结下来就是：</p>
<ul>
<li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li>
<li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法返回 <code>true</code>，我们才认为这两个对象相等。</li>
<li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li>
</ul>
<h2 id="为什么重写-equals-时必须重写-hashcode-方法"> 为什么重写 equals() 时必须重写 hashCode() 方法？</h2>
<p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>
<h2 id="包装类型的常量池技术"> 包装类型的常量池技术</h2>
<p>Java基本类型的包装类大部分都实现了常量池技术，
即Byte，Short，Integer，Long，Character，Boolean，这 6 种包装类默认创建了数值
<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>[</span><span>−</span><span>128</span><span>，</span><span>127</span><span>]</span></span></span></span> 的相应类型的缓存数据， 但是超出此范围仍然会去创建新的对象。
两种浮点数类型的包装类 Float、Double 并没有实现常量池技术。</p>
<div><pre><code><span>Integer</span> i1 <span>=</span> <span>40</span><span>;</span>
<span>Integer</span> i2 <span>=</span> <span>40</span><span>;</span>
<span>Integer</span> i3 <span>=</span> <span>0</span><span>;</span>
<span>Integer</span> i4 <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>40</span><span>)</span><span>;</span>
<span>Integer</span> i5 <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>40</span><span>)</span><span>;</span>
<span>Integer</span> i6 <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>0</span><span>)</span><span>;</span>
  
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"i1=i2   "</span> <span>+</span> <span>(</span>i1 <span>==</span> i2<span>)</span><span>)</span><span>;</span> <span>//输出 i1=i2  true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"i1=i2+i3   "</span> <span>+</span> <span>(</span>i1 <span>==</span> i2 <span>+</span> i3<span>)</span><span>)</span><span>;</span> <span>//输出 i1=i2+i3  true</span>
<span>//i2+i3得到40,比较的是数值</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"i1=i4   "</span> <span>+</span> <span>(</span>i1 <span>==</span> i4<span>)</span><span>)</span><span>;</span> <span>//输出 i1=i4 false</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"i4=i5   "</span> <span>+</span> <span>(</span>i4 <span>==</span> i5<span>)</span><span>)</span><span>;</span> <span>//输出 i4=i5 false</span>
<span>//i5+i6得到40，比较的是数值</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"i4=i5+i6   "</span> <span>+</span> <span>(</span>i4 <span>==</span> i5 <span>+</span> i6<span>)</span><span>)</span><span>;</span> <span>//输出 i4=i5+i6 true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"40=i5+i6   "</span> <span>+</span> <span>(</span><span>40</span> <span>==</span> i5 <span>+</span> i6<span>)</span><span>)</span><span>;</span> <span>//输出 40=i5+i6 true </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>以上提到的几种基本类型包装类均实现了常量池技术，但他们维护的常量仅仅是<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>[</span><span>−</span><span>128</span><span>,</span><span style="margin-right:0.1667em;"></span><span>127</span><span>]</span></span></span></span>这个范围内的常量，如果常量值超过这个范围，就会从堆中创建对象，不再从常量池中取。</p>
<p>比如，把上边例子改成Integer i1 = 400; Integer i2 = 400;，很明显超过了127，无法从常量池获取常量，就要从堆中new新的Integer对象，这时i1和i2就不相等了。</p>
<h2 id="自动装箱与拆箱"> 自动装箱与拆箱</h2>
<ul>
<li><strong>装箱：</strong> 将基本类型用它们对应的引用类型包装起来</li>
<li><strong>拆箱：</strong> 将包装类型转换为基本数据类型</li>
</ul>
<div><pre><code><span>Integer</span> i <span>=</span> <span>10</span><span>;</span>  <span>//装箱</span>
<span>int</span> n <span>=</span> i<span>;</span>   <span>//拆箱</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>注意：</strong> 如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</p>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">异常</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/Java%E5%9F%BA%E7%A1%80/%E5%BC%82%E5%B8%B8/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/Java%E5%9F%BA%E7%A1%80/%E5%BC%82%E5%B8%B8/"/>
    <updated>2022-02-21T13:44:21.677Z</updated>
    <content type="html"><![CDATA[<h2 id="异常"> 异常</h2>
<p>异常时程序经常会出现的，发现错误的最佳时机是在编译阶段，也就是你试图在运行程序之前。但是，在编译期间并不能找到所有的错误，有一些 <code>NullPointerException</code> 和 <code>ClassNotFoundException</code> 异常在编译期找不到，这些异常是 <code>RuntimeException</code> 运行时异常，这些异常往往在运行时才能被发现。</p>
<p>我们写 Java 程序经常会出现两种问题，一种是 java.lang.Exception，一种是 java.lang.Error，都用来表示出现了异常情况，下面就针对这两种概念进行理解。</p>
<h2 id="认识exception"> 认识Exception</h2>
<p><code>Exception</code> 位于 <code>java.lang</code> 包下，它是一种顶级接口，继承于 <code>Throwable</code> 类，Exception 类及其子类都是 Throwable 的组成条件，是程序出现的合理情况。</p>
<p>在认识Exception 之前，有必要先了解一下什么是 <code>Throwable</code></p>
<h2 id="什么是throwable"> 什么是Throwable</h2>
<p>Throwable 类是 Java 语言中所有 <code>错误(errors)</code> 和<code>异常(exceptions)</code>的父类。只有继承于 Throwable的类或者其子类才能够被抛出，还有一种方式是带有 Java 中的 <code>@throw</code> 注解的类也可以抛出。</p>
<p>在 Java 规范中，对非受查异常和受查异常的定义是这样的：</p>
<p>也就是说，除了 <code>RuntimeException</code> 和其子类，以及<code>error</code>和其子类，其它的所有异常都是<code>checkedException</code>。</p>
<p>那么，按照这种逻辑关系，我们可以对 Throwable 及其子类进行归类分析。</p>
<p><img src="http://blog.tryna.top/img/2022-01-19-14-00-27.png" alt="" loading="lazy"></p>
<p>可以看到，Throwable 位于异常和错误的最顶层，我们查看 Throwable类中发现它的方法和属性有很多，我们只讨论其中几个比较常用的。</p>
<div><pre><code><span>// 返回抛出异常的详细信息</span>
<span>public</span> <span>String</span> <span>getMessage</span><span>(</span><span>)</span><span>;</span>
<span>public</span> <span>String</span> <span>getLocalizedMessage</span><span>(</span><span>)</span><span>;</span>

<span>// 返回异常发生时的简要描述</span>
<span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span><span>;</span>

<span>// 打印异常信息到标准输出流上</span>
<span>public</span> <span>void</span> <span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
<span>public</span> <span>void</span> <span>printStackTrace</span><span>(</span><span>PrintStream</span> s<span>)</span><span>;</span>
<span>public</span> <span>void</span> <span>printStackTrace</span><span>(</span><span>PrintWriter</span> s<span>)</span><span>;</span>

<span>// 记录栈帧的当前状态</span>
<span>public</span> <span>synchronized</span> <span>Throwable</span> <span>fillInStackTrace</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>此外，因为 Throwable 的父类也是 <code>Object</code>, 所以常用的方法还有继承其父类的<code>getClass()</code> 和 <code>getName()</code> 方法。</p>
<h2 id="常见的exception"> 常见的Exception</h2>
<p>Exception有两种异常，一种是 <code>RuntimeException</code>, 是运行期的异常，编译的时候可以通过，但运行的时候会抛出来；一种是<code>CheckedException</code> , 是编译期的异常，一般是强制处理的，否则就会编译失败，这两种异常都应该去捕获。</p>
<p>下面列出了一些常见的异常：</p>
<p><strong>RuntimeException：</strong></p>
<table>
<thead>
<tr>
<th>异常名称</th>
<th>异常描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayIndexOutofBoundsException</td>
<td>数组越界异常</td>
</tr>
<tr>
<td>NullPointerException</td>
<td>空指针异常</td>
</tr>
<tr>
<td>IllegalArgumentException</td>
<td>非法参数异常</td>
</tr>
<tr>
<td>NegativeArraySizeException</td>
<td>数组长度为负异常</td>
</tr>
<tr>
<td>IllegalStateException</td>
<td>非法状态异常</td>
</tr>
<tr>
<td>ClassCastException</td>
<td>类型转换异常</td>
</tr>
</tbody>
</table>
<p><strong>CheckedException</strong></p>
<table>
<thead>
<tr>
<th>异常名称</th>
<th>异常描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>NoSuchFieldException</td>
<td>表示该类没有指定名称抛出来的异常</td>
</tr>
<tr>
<td>NoSuchMethodException</td>
<td>表示该类没有指定方法抛出来的异常</td>
</tr>
<tr>
<td>IllegalAccessException</td>
<td>不允许访问某个类的异常</td>
</tr>
<tr>
<td>ClassNotFoundException</td>
<td>类没有找到抛出异常</td>
</tr>
</tbody>
</table>
<h2 id="与-exception-有关的关键字"> 与 Exception 有关的关键字</h2>
<p>在 Java 中有这几个关键字 <strong>throws、throw、try、finally、catch</strong> 与异常有关。</p>
<h3 id="throws-和-throw"> throws 和 throw</h3>
<p>在 Java 中，异常也就是一个对象，它能够被程序员自定义抛出或者应用程序抛出，必须借助于<code>throws</code> 和 <code>throw</code>语句来定义抛出异常。</p>
<p>throws 和 throw 通常是成对出现的。</p>
<div><pre><code><span>static</span> <span>void</span> <span>cacheException</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span><span>{</span>

    <span>throw</span> <span>new</span> <span>Exception</span><span>(</span><span>)</span><span>;</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>throw 语句用在方法体内，表示抛出异常，由方法体内的语句处理。 throws 语句用在方法声明后面，表示再抛出异常，由该方法的调用者来处理。</li>
<li>throws 主要是声明这个方法会抛出这种类型的异常，使它的调用者知道要捕获这个异常。throw是具体向外抛异常的动作，所以它是抛出一个异常实例。</li>
</ul>
<h3 id="try、finally、catch"> try、finally、catch</h3>
<p>这三个关键字主要有下面几种组合方式 <strong>try...catch、try...finally、try...catch...finally</strong></p>
<p>try...catch 表示对某一段代码可能抛出异常进行的捕获</p>
<div><pre><code><span>static</span> <span>void</span> <span>cacheException</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span><span>{</span>

    <span>int</span><span>[</span><span>]</span> a <span>=</span> <span>new</span> <span>int</span><span>[</span><span>10</span><span>]</span><span>;</span>

    <span>try</span> <span>{</span>
        a<span>[</span><span>11</span><span>]</span> <span>=</span> <span>10</span><span>;</span>
    <span>}</span><span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
        e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>try...finally 表示对一段代码不管执行情况如何，都会走finally中的代码。</p>
<div><pre><code><span>static</span> <span>void</span> <span>cacheException</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span><span>{</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>2</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"enter: i="</span> <span>+</span> i<span>)</span><span>;</span>
        <span>try</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"execute: i="</span> <span>+</span> i<span>)</span><span>;</span>
            <span>continue</span><span>;</span>
        <span>}</span> <span>finally</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"leave: i="</span> <span>+</span> i<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>输出：</p>
<div><pre><code>enter<span>:</span> i<span>=</span><span>0</span>
execute<span>:</span> i<span>=</span><span>0</span>
leave<span>:</span> i<span>=</span><span>0</span>
enter<span>:</span> i<span>=</span><span>1</span>
execute<span>:</span> i<span>=</span><span>1</span>
leave<span>:</span> i<span>=</span><span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>try...catch...finally 也是一样的，表示对异常捕获后，再走 finally 中的代码逻辑。</p>
<p><strong>注意：</strong> 在以下三种特殊情况下，<code>finally</code>块不会被执行：</p>
<ul>
<li>在 try 或 finally块中用了<code>System.exit(int)</code>退出程序。但是，如果 <code>System.exit(int)</code> 在异常语句之后，finally 还是会被执行</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ul>
<p><strong>注意：</strong> 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>
    <span>public</span> <span>static</span> <span>int</span> <span>f</span><span>(</span><span>int</span> value<span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
            <span>return</span> value <span>*</span> value<span>;</span>
        <span>}</span> <span>finally</span> <span>{</span>
            <span>if</span> <span>(</span>value <span>==</span> <span>2</span><span>)</span> <span>{</span>
                <span>return</span> <span>0</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>如果调用 f(2)，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。</p>
<h2 id="error"> Error</h2>
<p>Error 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（VirtualMachineError）、虚拟机内存不够错误(OutOfMemoryError)、栈溢出错误(StackOverFlowError) 、 类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">集合判空</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/Java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/Java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <updated>2022-02-21T13:44:21.693Z</updated>
    <content type="html"><![CDATA[<h2 id="集合判空"> 集合判空</h2>
<blockquote>
<p>判断所有集合内部的元素是否为空，使用 <code>isEmpty()</code> 方法，而不是 <code>size()==0</code> 的方式。</p>
</blockquote>
<p>这是因为 <code>isEmpty()</code> 方法的可读性更好，并且时间复杂度为 O(1)。</p>
<p>绝大部分我们使用的集合的 <code>size()</code> 方法的时间复杂度也是 O(1)，不过，也有很多复杂度不是 O(1) 的，比如 <code>java.util.concurrent</code> 包下的某些集合（<code>ConcurrentLinkedQueue</code> 、<code>ConcurrentHashMap</code>...）</p>
<p>下面是 <code>ConcurrentHashMap</code> 的 <code>size()</code> 方法和 <code>isEmpty()</code> 方法的源码。</p>
<div><pre><code><span>public</span> <span>int</span> <span>size</span><span>(</span><span>)</span> <span>{</span>
    <span>long</span> n <span>=</span> <span>sumCount</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>(</span>n <span>&lt;</span> <span>0L</span><span>)</span> <span>?</span> <span>0</span> <span>:</span>
            <span>(</span>n <span>></span> <span>(</span><span>long</span><span>)</span><span>Integer</span><span>.</span>MAX_VALUE<span>)</span> <span>?</span> <span>Integer</span><span>.</span>MAX_VALUE <span>:</span>
            <span>(</span><span>int</span><span>)</span>n<span>)</span><span>;</span>
<span>}</span>
<span>final</span> <span>long</span> <span>sumCount</span><span>(</span><span>)</span> <span>{</span>
    <span>CounterCell</span><span>[</span><span>]</span> as <span>=</span> counterCells<span>;</span> <span>CounterCell</span> a<span>;</span>
    <span>long</span> sum <span>=</span> baseCount<span>;</span>
    <span>if</span> <span>(</span>as <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> as<span>.</span>length<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>(</span>a <span>=</span> as<span>[</span>i<span>]</span><span>)</span> <span>!=</span> <span>null</span><span>)</span>
                sum <span>+=</span> a<span>.</span>value<span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> sum<span>;</span>
<span>}</span>
<span>public</span> <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>sumCount</span><span>(</span><span>)</span> <span>&lt;=</span> <span>0L</span><span>;</span> <span>// ignore transient negative values</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id="集合转-map"> 集合转 Map</h2>
<blockquote>
<p>在使用 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法转为 <code>Map</code> 集合时，一定要注意当 <code>value</code> 为 null 时会抛 NPE 异常。</p>
</blockquote>
<div><pre><code><span>class</span> <span>Person</span> <span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>String</span> phoneNumber<span>;</span>
     <span>// getters and setters</span>
<span>}</span>

<span>List</span><span><span>&lt;</span><span>Person</span><span>></span></span> bookList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
bookList<span>.</span><span>add</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>"jack"</span><span>,</span><span>"18163138123"</span><span>)</span><span>)</span><span>;</span>
bookList<span>.</span><span>add</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>"martin"</span><span>,</span><span>null</span><span>)</span><span>)</span><span>;</span>
<span>// 空指针异常</span>
bookList<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>collect</span><span>(</span><span>Collectors</span><span>.</span><span>toMap</span><span>(</span><span>Person</span><span>::</span><span>getName</span><span>,</span> <span>Person</span><span>::</span><span>getPhoneNumber</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>下面我们来解释一下原因。</p>
<p>首先，我们来看 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法 ，可以看到其内部调用了 <code>Map</code> 接口的 <code>merge()</code> 方法。</p>
<div><pre><code><span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>,</span> <span>K</span><span>,</span> <span>U</span><span>,</span> <span>M</span> <span>extends</span> <span>Map</span><span>&lt;</span><span>K</span><span>,</span> <span>U</span><span>></span><span>></span></span>
<span>Collector</span><span><span>&lt;</span><span>T</span><span>,</span> <span>?</span><span>,</span> <span>M</span><span>></span></span> <span>toMap</span><span>(</span><span>Function</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>,</span> <span>?</span> <span>extends</span> <span>K</span><span>></span></span> keyMapper<span>,</span>
                            <span>Function</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>,</span> <span>?</span> <span>extends</span> <span>U</span><span>></span></span> valueMapper<span>,</span>
                            <span>BinaryOperator</span><span><span>&lt;</span><span>U</span><span>></span></span> mergeFunction<span>,</span>
                            <span>Supplier</span><span><span>&lt;</span><span>M</span><span>></span></span> mapSupplier<span>)</span> <span>{</span>
    <span>BiConsumer</span><span><span>&lt;</span><span>M</span><span>,</span> <span>T</span><span>></span></span> accumulator
            <span>=</span> <span>(</span>map<span>,</span> element<span>)</span> <span>-></span> map<span>.</span><span>merge</span><span>(</span>keyMapper<span>.</span><span>apply</span><span>(</span>element<span>)</span><span>,</span>
                                          valueMapper<span>.</span><span>apply</span><span>(</span>element<span>)</span><span>,</span> mergeFunction<span>)</span><span>;</span>
    <span>return</span> <span>new</span> <span>CollectorImpl</span><span><span>&lt;</span><span>></span></span><span>(</span>mapSupplier<span>,</span> accumulator<span>,</span> <span>mapMerger</span><span>(</span>mergeFunction<span>)</span><span>,</span> CH_ID<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><code>Map</code> 接口的 <code>merge()</code> 方法如下，这个方法是接口中的默认实现。</p>
<div><pre><code><span>default</span> <span>V</span> <span>merge</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>,</span>
        <span>BiFunction</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>V</span><span>,</span> <span>?</span> <span>super</span> <span>V</span><span>,</span> <span>?</span> <span>extends</span> <span>V</span><span>></span></span> remappingFunction<span>)</span> <span>{</span>
    <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>remappingFunction<span>)</span><span>;</span>
    <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>value<span>)</span><span>;</span>
    <span>V</span> oldValue <span>=</span> <span>get</span><span>(</span>key<span>)</span><span>;</span>
    <span>V</span> newValue <span>=</span> <span>(</span>oldValue <span>==</span> <span>null</span><span>)</span> <span>?</span> value <span>:</span>
               remappingFunction<span>.</span><span>apply</span><span>(</span>oldValue<span>,</span> value<span>)</span><span>;</span>
    <span>if</span><span>(</span>newValue <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>remove</span><span>(</span>key<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>put</span><span>(</span>key<span>,</span> newValue<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> newValue<span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><code>merge()</code> 方法会先调用 <code>Objects.requireNonNull()</code> 方法判断 value 是否为空。</p>
<div><pre><code><span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>requireNonNull</span><span>(</span><span>T</span> obj<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>obj <span>==</span> <span>null</span><span>)</span>
        <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> obj<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="集合遍历"> 集合遍历</h2>
<blockquote>
<p>不要在 <code>foreach</code> 循环里进行元素的 <code>remove/add</code> 操作。<code>remove</code> 元素请使用 <code>Iterator</code> 方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁。</p>
</blockquote>
<p>通过反编译你会发现 <code>foreach</code> 语法糖底层其实还是依赖 <code>Iterator</code> 。不过， <code>remove/add</code> 操作直接调用的是集合自己的方法，而不是 <code>Iterator</code> 的 <code>remove/add</code>方法</p>
<p>这就导致 <code>Iterator</code> 莫名其妙地发现自己有元素被 <code>remove/add</code> ，然后，它就会抛出一个 <code>ConcurrentModificationException</code> 来提示用户发生了并发修改异常。这就是单线程状态下产生的 <strong>fail-fast 机制</strong> 。</p>
<blockquote>
<p><strong>fail-fast 机制 ：</strong> 多个线程对 fail-fast 集合进行修改的时候，可能会抛出<code>ConcurrentModificationException</code>。 即使是单线程下也有可能会出现这种情况，上面已经提到过。</p>
</blockquote>
<p>Java8 开始，可以使用 <code>Collection#removeIf()</code>方法删除满足特定条件的元素,如</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> <span>10</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span>
    list<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>
<span>}</span>
list<span>.</span><span>removeIf</span><span>(</span>filter <span>-></span> filter <span>%</span> <span>2</span> <span>==</span> <span>0</span><span>)</span><span>;</span> <span>/* 删除list中的所有偶数 */</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>list<span>)</span><span>;</span> <span>/* [1, 3, 5, 7, 9] */</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>除了上面介绍的直接使用 <code>Iterator</code> 进行遍历操作之外，你还可以：</p>
<ul>
<li>使用普通的 for 循环</li>
<li>使用 <code>fail-safe</code> 的集合类。<code>java.util</code>包下面的所有的集合类都是 <code>fail-fast</code> 的，而<code>java.util.concurrent</code>包下面的所有的类都是 <code>fail-safe</code> 的。</li>
</ul>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">Java 集合概览</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/Java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/Java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88/"/>
    <updated>2022-02-21T13:44:21.754Z</updated>
    <content type="html"><![CDATA[<h2 id="java-集合概览"> Java 集合概览</h2>
<p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</p>
<p>Java 集合框架如下图所示：</p>
<p><img src="https://javaguide.cn/assets/img/java-collection-hierarchy.71519bdb.png" alt="" loading="lazy"></p>
<p>我感觉网上那张神图没有这张图清晰。但这张图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了<code>AbstractList</code>, <code>NavigableSet</code>等抽象类以及其他的一些辅助类</p>
<h2 id="list-set-queue-map-四者的区别"> List, Set, Queue, Map 四者的区别？</h2>
<ul>
<li><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</li>
<li><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li>
<li><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>
<li><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，&quot;x&quot; 代表 key，&quot;y&quot; 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>
</ul>
<h2 id="集合框架底层数据结构总结"> 集合框架底层数据结构总结</h2>
<p>先来看一下 <code>Collection</code> 接口下面的集合。</p>
<h3 id="list"> List</h3>
<ul>
<li><code>Arraylist</code>： <code>Object[]</code> 数组</li>
<li><code>Vector</code>：<code>Object[]</code> 数组</li>
<li><code>LinkedList</code>：双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li>
</ul>
<h3 id="set"> Set</h3>
<ul>
<li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li>
<li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li>
<li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li>
</ul>
<h3 id="queue"> Queue</h3>
<ul>
<li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li>
<li><code>ArrayDeque</code>: <code>Object[]</code> 数组 + 双指针</li>
</ul>
<p>再来看看 <code>Map</code> 接口下面的集合。</p>
<h3 id="map"> Map</h3>
<ul>
<li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>
<li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li>
</ul>
<h2 id="如何选用集合"> 如何选用集合?</h2>
<p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>,不需要排序时就选择 <code>HashMap</code>,需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</p>
<p>当我们只需要存放元素值时，就选择实现<code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</p>
<h2 id="为什么要使用集合"> 为什么要使用集合？</h2>
<p>当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端，
因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。</p>
<p>数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。
但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。</p>
<h2 id="collection-子接口之-list"> Collection 子接口之 List</h2>
<h3 id="arraylist-和-vector-的区别"> Arraylist 和 Vector 的区别?</h3>
<ul>
<li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</li>
<li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[ ]</code> 存储，线程安全的。</li>
</ul>
<h3 id="arraylist-与-linkedlist-区别"> Arraylist 与 LinkedList 区别?</h3>
<p><strong>1.是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全</p>
<p><strong>2.底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <code>Object</code> 数组；<code>LinkedList</code> 底层使用的是 双向链表 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</p>
<p><strong>3.插入和删除是否受元素位置的影响：</strong></p>
<ul>
<li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span>。但是如果要在指定位置 i 插入和删除元素的话<code>add(int index, E element)</code>时间复杂度就为 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>n</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>i</span><span>)</span></span></span></span>。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li>
<li><code>LinkedList</code> 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code> 、 <code>removeLast()</code>），近似 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span>，如果是要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>） 时间复杂度近似为 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>n</span><span>)</span></span></span></span> ，因为需要先移动到指定位置再插入。</li>
</ul>
<p><strong>4.是否支持快速随机访问：</strong>  <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p>
<p><strong>5.内存空间占用：</strong> ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）</p>
<p><strong>双向链表：</strong> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/双向链表.png" alt="" loading="lazy"></p>
<p><strong>双向循环链表：</strong> 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/双向循环链表.png" alt="" loading="lazy"></p>
<p><strong>RandomAccess 接口</strong></p>
<div><pre><code><span>public</span> <span>interface</span> <span>RandomAccess</span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>查看源码我们发现实际上 <code>RandomAccess</code> 接口中什么都没有定义。所以，在我看来 <code>RandomAccess</code> 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p>
<p>在 <code>binarySearch()</code> 方法中，它要判断传入的 <code>list</code> 是否 <code>RamdomAccess</code> 的实例，如果是，调用<code>indexedBinarySearch()</code>方法，如果不是，那么调用<code>iteratorBinarySearch()</code>方法</p>
<div><pre><code><span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span>
<span>int</span> <span>binarySearch</span><span>(</span><span>List</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Comparable</span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span><span>></span></span> list<span>,</span> <span>T</span> key<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>list <span>instanceof</span> <span>RandomAccess</span> <span>||</span> list<span>.</span><span>size</span><span>(</span><span>)</span><span>&lt;</span>BINARYSEARCH_THRESHOLD<span>)</span>
        <span>return</span> <span>Collections</span><span>.</span><span>indexedBinarySearch</span><span>(</span>list<span>,</span> key<span>)</span><span>;</span>
    <span>else</span>
        <span>return</span> <span>Collections</span><span>.</span><span>iteratorBinarySearch</span><span>(</span>list<span>,</span> key<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口， 而 <code>LinkedList</code> 没有实现。为什么呢？我觉得还是和底层数据结构有关！<code>ArrayList</code> 底层是数组，而 <code>LinkedList</code> 底层是链表。数组天然支持随机访问，时间复杂度为 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span>，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>n</span><span>)</span></span></span></span>，所以不支持快速随机访问。<code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，就表明了他具有快速随机访问功能。 <code>RandomAccess</code> 接口只是标识，并不是说 <code>ArrayList</code> 实现 <code>RandomAccess</code> 接口才具有快速随机访问功能的！</p>
<h2 id="arraylist-扩容机制分析"> ArrayList 扩容机制分析</h2>
<h3 id="先从-arraylist-的构造函数说起"> 先从 ArrayList 的构造函数说起</h3>
<p>（JDK8）ArrayList 有三种方式来初始化，构造方法源码如下：</p>
<div><pre><code><span>/**
  * 默认初始容量大小
  */</span>
<span>private</span> <span>static</span> <span>final</span> <span>int</span> DEFAULT_CAPACITY <span>=</span> <span>10</span><span>;</span>


<span>private</span> <span>static</span> <span>final</span> <span>Object</span><span>[</span><span>]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span>=</span> <span>{</span><span>}</span><span>;</span>

<span>/**
  *默认构造函数，使用初始容量10构造一个空列表(无参数构造)
  */</span>
<span>public</span> <span>ArrayList</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>elementData <span>=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>;</span>
<span>}</span>

<span>/**
  * 带初始容量参数的构造函数。（用户自己指定容量）
  */</span>
<span>public</span> <span>ArrayList</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>initialCapacity <span>></span> <span>0</span><span>)</span> <span>{</span><span>//初始容量大于0</span>
        <span>//创建initialCapacity大小的数组</span>
        <span>this</span><span>.</span>elementData <span>=</span> <span>new</span> <span>Object</span><span>[</span>initialCapacity<span>]</span><span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>initialCapacity <span>==</span> <span>0</span><span>)</span> <span>{</span><span>//初始容量等于0</span>
        <span>//创建空数组</span>
        <span>this</span><span>.</span>elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>
    <span>}</span> <span>else</span> <span>{</span><span>//初始容量小于0，抛出异常</span>
        <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>"Illegal Capacity: "</span><span>+</span>
                                            initialCapacity<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>


<span>/**
*构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回
*如果指定的集合为null，throws NullPointerException。
*/</span>
  <span>public</span> <span>ArrayList</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>
    elementData <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span><span>(</span>size <span>=</span> elementData<span>.</span>length<span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
        <span>// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>
        <span>if</span> <span>(</span>elementData<span>.</span><span>getClass</span><span>(</span><span>)</span> <span>!=</span> <span>Object</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span>
            elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>,</span> <span>Object</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>// replace with empty array.</span>
        <span>this</span><span>.</span>elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><p>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。 下面在我们分析 ArrayList 扩容时会讲到这一点内容！</p>
<blockquote>
<p>补充：JDK6 new 无参构造的 ArrayList 对象时，直接创建了长度是 10 的 Object[] 数组 elementData 。</p>
</blockquote>
<h3 id="一步一步分析-arraylist-扩容机制"> 一步一步分析 ArrayList 扩容机制</h3>
<p>这里以无参构造函数创建的 ArrayList 为例分析</p>
<h4 id="先来看-add-方法"> 先来看 add 方法</h4>
<div><pre><code><span>/**
  * 将指定的元素追加到此列表的末尾。
  */</span>
<span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>
<span>//添加元素之前，先调用ensureCapacityInternal方法</span>
    <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  <span>// Increments modCount!!</span>
    <span>//这里看到ArrayList添加元素的实质就相当于为数组赋值</span>
    elementData<span>[</span>size<span>++</span><span>]</span> <span>=</span> e<span>;</span>
    <span>return</span> <span>true</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>
<p>注意 ：JDK11 移除了 ensureCapacityInternal() 和 ensureExplicitCapacity() 方法</p>
</blockquote>
<h4 id="再来看看-ensurecapacityinternal-方法"> 再来看看 ensureCapacityInternal() 方法</h4>
<p>（JDK7）可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p>
<div><pre><code><span>//得到最小扩容量</span>
<span>private</span> <span>void</span> <span>ensureCapacityInternal</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>elementData <span>==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>)</span> <span>{</span>
          <span>// 获取默认的容量和传入参数的较大值</span>
        minCapacity <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>DEFAULT_CAPACITY<span>,</span> minCapacity<span>)</span><span>;</span>
    <span>}</span>

    <span>ensureExplicitCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><strong>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</strong></p>
<blockquote>
<p>此处和后续 JDK8 代码格式化略有不同，核心代码基本一样。</p>
</blockquote>
<h4 id="ensureexplicitcapacity-方法"> ensureExplicitCapacity() 方法</h4>
<p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进入（执行）这个方法，下面我们来研究一下这个方法的源码！</p>
<div><pre><code><span>//判断是否需要扩容</span>
<span>private</span> <span>void</span> <span>ensureExplicitCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
    modCount<span>++</span><span>;</span>

    <span>// overflow-conscious code</span>
    <span>if</span> <span>(</span>minCapacity <span>-</span> elementData<span>.</span>length <span>></span> <span>0</span><span>)</span>
        <span>//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span>
        <span>grow</span><span>(</span>minCapacity<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ul>
<li>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li>
<li>当 add 第 2 个元素时，minCapacity 为 2，此时 e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li>
<li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li>
</ul>
<p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p>
<h4 id="grow-方法"> grow() 方法</h4>
<div><pre><code><span>/**
  * 要分配的最大数组大小
  */</span>
<span>private</span> <span>static</span> <span>final</span> <span>int</span> MAX_ARRAY_SIZE <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE <span>-</span> <span>8</span><span>;</span>

<span>/**
  * ArrayList扩容的核心方法。
  */</span>
<span>private</span> <span>void</span> <span>grow</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
    <span>// oldCapacity为旧容量，newCapacity为新容量</span>
    <span>int</span> oldCapacity <span>=</span> elementData<span>.</span>length<span>;</span>
    <span>//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span>
    <span>//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span>
    <span>int</span> newCapacity <span>=</span> oldCapacity <span>+</span> <span>(</span>oldCapacity <span>>></span> <span>1</span><span>)</span><span>;</span>
    <span>//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span>
    <span>if</span> <span>(</span>newCapacity <span>-</span> minCapacity <span>&lt;</span> <span>0</span><span>)</span>
        newCapacity <span>=</span> minCapacity<span>;</span>
    <span>// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span>
    <span>//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span>
    <span>if</span> <span>(</span>newCapacity <span>-</span> MAX_ARRAY_SIZE <span>></span> <span>0</span><span>)</span>
        newCapacity <span>=</span> <span>hugeCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>
    <span>// minCapacity is usually close to size, so this is a win:</span>
    elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> newCapacity<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</p>
<ul>
<li>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity = minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return true,size 增为 1。</li>
<li>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。</li>
<li>以此类推······</li>
</ul>
<p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p>
<ul>
<li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 <code>length</code> 这个属性.</li>
<li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li>
<li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li>
</ul>
<h4 id="hugecapacity-方法。"> hugeCapacity() 方法。</h4>
<p>从上面 grow() 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) hugeCapacity() 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 Integer.MAX_VALUE - 8。</p>
<div><pre><code><span>private</span> <span>static</span> <span>int</span> <span>hugeCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>minCapacity <span>&lt;</span> <span>0</span><span>)</span> <span>// overflow</span>
        <span>throw</span> <span>new</span> <span>OutOfMemoryError</span><span>(</span><span>)</span><span>;</span>
    <span>//对minCapacity和MAX_ARRAY_SIZE进行比较</span>
    <span>//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span>
    <span>//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span>
    <span>//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span>
    <span>return</span> <span>(</span>minCapacity <span>></span> MAX_ARRAY_SIZE<span>)</span> <span>?</span>
        <span>Integer</span><span>.</span>MAX_VALUE <span>:</span>
        MAX_ARRAY_SIZE<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="system-arraycopy-和-arrays-copyof-方法"> System.arraycopy() 和 Arrays.copyOf()方法</h3>
<p>阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p>
<h4 id="system-arraycopy-方法"> System.arraycopy() 方法</h4>
<div><pre><code><span>// 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义</span>
<span>/**
*   复制数组
* @param src 源数组
* @param srcPos 源数组中的起始位置
* @param dest 目标数组
* @param destPos 目标数组中的起始位置
* @param length 要复制的数组元素的数量
*/</span>
<span>public</span> <span>static</span> <span>native</span> <span>void</span> <span>arraycopy</span><span>(</span><span>Object</span> src<span>,</span>  <span>int</span>  srcPos<span>,</span>
                                    <span>Object</span> dest<span>,</span> <span>int</span> destPos<span>,</span>
                                    <span>int</span> length<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>/**
  * 在此列表中的指定位置插入指定的元素。
  *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；
  *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。
  */</span>
<span>public</span> <span>void</span> <span>add</span><span>(</span><span>int</span> index<span>,</span> <span>E</span> element<span>)</span> <span>{</span>
    <span>rangeCheckForAdd</span><span>(</span>index<span>)</span><span>;</span>

    <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  <span>// Increments modCount!!</span>
    <span>//arraycopy()方法实现数组自己复制自己</span>
    <span>//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span>
    <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>,</span> elementData<span>,</span> index <span>+</span> <span>1</span><span>,</span> size <span>-</span> index<span>)</span><span>;</span>
    elementData<span>[</span>index<span>]</span> <span>=</span> element<span>;</span>
    size<span>++</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>我们写一个简单的方法测试以下：</p>
<div><pre><code><span>public</span> <span>class</span> <span>ArraycopyTest</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// TODO Auto-generated method stub</span>
        <span>int</span><span>[</span><span>]</span> a <span>=</span> <span>new</span> <span>int</span><span>[</span><span>10</span><span>]</span><span>;</span>
        a<span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
        a<span>[</span><span>1</span><span>]</span> <span>=</span> <span>1</span><span>;</span>
        a<span>[</span><span>2</span><span>]</span> <span>=</span> <span>2</span><span>;</span>
        a<span>[</span><span>3</span><span>]</span> <span>=</span> <span>3</span><span>;</span>
        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>a<span>,</span> <span>2</span><span>,</span> a<span>,</span> <span>3</span><span>,</span> <span>3</span><span>)</span><span>;</span>
        a<span>[</span><span>2</span><span>]</span><span>=</span><span>99</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> a<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>a<span>[</span>i<span>]</span> <span>+</span> <span>" "</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>结果：</p>
<div><pre><code><span>0</span> <span>1</span> <span>99</span> <span>2</span> <span>3</span> <span>0</span> <span>0</span> <span>0</span> <span>0</span> <span>0</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="arrays-copyof-方法"> Arrays.copyOf()方法</h4>
<div><pre><code><span>public</span> <span>static</span> <span>int</span><span>[</span><span>]</span> <span>copyOf</span><span>(</span><span>int</span><span>[</span><span>]</span> original<span>,</span> <span>int</span> newLength<span>)</span> <span>{</span>
    <span>// 申请一个新的数组</span>
    <span>int</span><span>[</span><span>]</span> copy <span>=</span> <span>new</span> <span>int</span><span>[</span>newLength<span>]</span><span>;</span>
<span>// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span>
    <span>System</span><span>.</span><span>arraycopy</span><span>(</span>original<span>,</span> <span>0</span><span>,</span> copy<span>,</span> <span>0</span><span>,</span>
                      <span>Math</span><span>.</span><span>min</span><span>(</span>original<span>.</span>length<span>,</span> newLength<span>)</span><span>)</span><span>;</span>
    <span>return</span> copy<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>个人觉得使用 Arrays.copyOf()方法主要是为了给原有数组扩容，测试代码如下：</p>
<div><pre><code><span>public</span> <span>class</span> <span>ArrayscopyOfTest</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span><span>[</span><span>]</span> a <span>=</span> <span>new</span> <span>int</span><span>[</span><span>3</span><span>]</span><span>;</span>
        a<span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
        a<span>[</span><span>1</span><span>]</span> <span>=</span> <span>1</span><span>;</span>
        a<span>[</span><span>2</span><span>]</span> <span>=</span> <span>2</span><span>;</span>
        <span>int</span><span>[</span><span>]</span> b <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>a<span>,</span> <span>10</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"b.length"</span><span>+</span>b<span>.</span>length<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>结果：</p>
<div><pre><code>b.length10
</code></pre>
<div><span>1</span><br></div></div><p><strong>Issue:</strong> 其实我还不明白为什么b的length为10，因为<code>copyOf()</code>的源码是原数组长度和<code>newLength</code>取小，按照我的理解，传入的<code>arrayCopy()</code>函数的<code>length</code>参数应为<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>3</span></span></span></span>，所以应该复制的长度为<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>3</span></span></span></span>。</p>
<blockquote>
<p>我蒿菜，没注意的<code>copyOf()</code>的返回值，copy数组的长度就已经是<code>newLength</code>了。</p>
</blockquote>
<h4 id="两者联系和区别"> 两者联系和区别</h4>
<p><strong>联系：</strong> 看两者源代码可以发现 <code>copyOf()</code>内部实际调用了 <code>System.arraycopy()</code> 方法</p>
<p><strong>区别：</strong></p>
<ul>
<li><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置</li>
<li><code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</li>
</ul>
<h3 id="ensurecapacity方法"> ensureCapacity方法</h3>
<p><code>ArrayList</code> 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 <code>ArrayList</code> 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p>
<div><pre><code><span>/**
如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。
  *
  * @param   minCapacity   所需的最小容量
  */</span>
<span>public</span> <span>void</span> <span>ensureCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
    <span>int</span> minExpand <span>=</span> <span>(</span>elementData <span>!=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>)</span>
        <span>// any size if not default element table</span>
        <span>?</span> <span>0</span>
        <span>// larger than default for default empty table. It's already</span>
        <span>// supposed to be at default size.</span>
        <span>:</span> DEFAULT_CAPACITY<span>;</span>

    <span>if</span> <span>(</span>minCapacity <span>></span> minExpand<span>)</span> <span>{</span>
        <span>ensureExplicitCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>最好在 add 大量元素之前用 ensureCapacity 方法，以减少增量重新分配的次数</p>
<div><pre><code><span>public</span> <span>class</span> <span>EnsureCapacityTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>final</span> <span>int</span> <span>N</span> <span>=</span> <span>10000000</span><span>;</span>
        <span>long</span> startTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            list<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>
        <span>}</span>
        <span>long</span> endTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"使用ensureCapacity方法前："</span><span>+</span><span>(</span>endTime <span>-</span> startTime<span>)</span><span>)</span><span>;</span>

    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code>使用ensureCapacity方法前：<span>2158</span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>EnsureCapacityTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>final</span> <span>int</span> <span>N</span> <span>=</span> <span>10000000</span><span>;</span>
        list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>long</span> startTime1 <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
        list<span>.</span><span>ensureCapacity</span><span>(</span><span>N</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            list<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>
        <span>}</span>
        <span>long</span> endTime1 <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"使用ensureCapacity方法后："</span><span>+</span><span>(</span>endTime1 <span>-</span> startTime1<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code>使用ensureCapacity方法后：<span>1773</span>
</code></pre>
<div><span>1</span><br></div></div><p>通过运行结果，我们可以看出向 ArrayList 添加大量元素之前最好先使用<code>ensureCapacity</code> 方法，以减少增量重新分配的次数。</p>
<h3 id="arraylist-核心源码解读"> ArrayList 核心源码解读</h3>
<div><pre><code><span>package</span> <span>java<span>.</span>util</span><span>;</span>

<span>import</span> <span>java<span>.</span>util<span>.</span>function<span>.</span></span><span>Consumer</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>function<span>.</span></span><span>Predicate</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>function<span>.</span></span><span>UnaryOperator</span><span>;</span>


<span>public</span> <span>class</span> <span>ArrayList</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>AbstractList</span><span><span>&lt;</span><span>E</span><span>></span></span>
        <span>implements</span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span><span>,</span> <span>RandomAccess</span><span>,</span> <span>Cloneable</span><span>,</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span>
<span>{</span>
    <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID <span>=</span> <span>8683452581122892189L</span><span>;</span>

    <span>/**
     * 默认初始容量大小
     */</span>
    <span>private</span> <span>static</span> <span>final</span> <span>int</span> DEFAULT_CAPACITY <span>=</span> <span>10</span><span>;</span>

    <span>/**
     * 空数组（用于空实例）。
     */</span>
    <span>private</span> <span>static</span> <span>final</span> <span>Object</span><span>[</span><span>]</span> EMPTY_ELEMENTDATA <span>=</span> <span>{</span><span>}</span><span>;</span>

     <span>//用于默认大小空实例的共享空数组实例。</span>
      <span>//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span>
    <span>private</span> <span>static</span> <span>final</span> <span>Object</span><span>[</span><span>]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span>=</span> <span>{</span><span>}</span><span>;</span>

    <span>/**
     * 保存ArrayList数据的数组
     */</span>
    <span>transient</span> <span>Object</span><span>[</span><span>]</span> elementData<span>;</span> <span>// non-private to simplify nested class access</span>

    <span>/**
     * ArrayList 所包含的元素个数
     */</span>
    <span>private</span> <span>int</span> size<span>;</span>

    <span>/**
     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）
     */</span>
    <span>public</span> <span>ArrayList</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>initialCapacity <span>></span> <span>0</span><span>)</span> <span>{</span>
            <span>//如果传入的参数大于0，创建initialCapacity大小的数组</span>
            <span>this</span><span>.</span>elementData <span>=</span> <span>new</span> <span>Object</span><span>[</span>initialCapacity<span>]</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>initialCapacity <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>//如果传入的参数等于0，创建空数组</span>
            <span>this</span><span>.</span>elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>//其他情况，抛出异常</span>
            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>"Illegal Capacity: "</span><span>+</span>
                                               initialCapacity<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>/**
     *默认无参构造函数
     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10
     */</span>
    <span>public</span> <span>ArrayList</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>elementData <span>=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>;</span>
    <span>}</span>

    <span>/**
     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。
     */</span>
    <span>public</span> <span>ArrayList</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>
        <span>//将指定集合转换为数组</span>
        elementData <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>
        <span>//如果elementData数组的长度不为0</span>
        <span>if</span> <span>(</span><span>(</span>size <span>=</span> elementData<span>.</span>length<span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
            <span>// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）</span>
            <span>if</span> <span>(</span>elementData<span>.</span><span>getClass</span><span>(</span><span>)</span> <span>!=</span> <span>Object</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span>
                <span>//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span>
                elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>,</span> <span>Object</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>// 其他情况，用空数组代替</span>
            <span>this</span><span>.</span>elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>/**
     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。
     */</span>
    <span>public</span> <span>void</span> <span>trimToSize</span><span>(</span><span>)</span> <span>{</span>
        modCount<span>++</span><span>;</span>
        <span>if</span> <span>(</span>size <span>&lt;</span> elementData<span>.</span>length<span>)</span> <span>{</span>
            elementData <span>=</span> <span>(</span>size <span>==</span> <span>0</span><span>)</span>
              <span>?</span> EMPTY_ELEMENTDATA
              <span>:</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>//下面是ArrayList的扩容机制</span>
<span>//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span>
<span>//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span>
    <span>/**
     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量
     * @param   minCapacity   所需的最小容量
     */</span>
    <span>public</span> <span>void</span> <span>ensureCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
        <span>//如果是true，minExpand的值为0，如果是false,minExpand的值为10</span>
        <span>int</span> minExpand <span>=</span> <span>(</span>elementData <span>!=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>)</span>
            <span>// any size if not default element table</span>
            <span>?</span> <span>0</span>
            <span>// larger than default for default empty table. It's already</span>
            <span>// supposed to be at default size.</span>
            <span>:</span> DEFAULT_CAPACITY<span>;</span>
        <span>//如果最小容量大于已有的最大容量</span>
        <span>if</span> <span>(</span>minCapacity <span>></span> minExpand<span>)</span> <span>{</span>
            <span>ensureExplicitCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
   <span>//1.得到最小扩容量</span>
   <span>//2.通过最小容量扩容</span>
    <span>private</span> <span>void</span> <span>ensureCapacityInternal</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>elementData <span>==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>)</span> <span>{</span>
              <span>// 获取“默认的容量”和“传入参数”两者之间的最大值</span>
            minCapacity <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>DEFAULT_CAPACITY<span>,</span> minCapacity<span>)</span><span>;</span>
        <span>}</span>

        <span>ensureExplicitCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>
    <span>}</span>
  <span>//判断是否需要扩容</span>
    <span>private</span> <span>void</span> <span>ensureExplicitCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
        modCount<span>++</span><span>;</span>

        <span>// overflow-conscious code</span>
        <span>if</span> <span>(</span>minCapacity <span>-</span> elementData<span>.</span>length <span>></span> <span>0</span><span>)</span>
            <span>//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span>
            <span>grow</span><span>(</span>minCapacity<span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 要分配的最大数组大小
     */</span>
    <span>private</span> <span>static</span> <span>final</span> <span>int</span> MAX_ARRAY_SIZE <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE <span>-</span> <span>8</span><span>;</span>

    <span>/**
     * ArrayList扩容的核心方法。
     */</span>
    <span>private</span> <span>void</span> <span>grow</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
        <span>// oldCapacity为旧容量，newCapacity为新容量</span>
        <span>int</span> oldCapacity <span>=</span> elementData<span>.</span>length<span>;</span>
        <span>//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span>
        <span>//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span>
        <span>int</span> newCapacity <span>=</span> oldCapacity <span>+</span> <span>(</span>oldCapacity <span>>></span> <span>1</span><span>)</span><span>;</span>
        <span>//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span>
        <span>if</span> <span>(</span>newCapacity <span>-</span> minCapacity <span>&lt;</span> <span>0</span><span>)</span>
            newCapacity <span>=</span> minCapacity<span>;</span>
        <span>//再检查新容量是否超出了ArrayList所定义的最大容量，</span>
        <span>//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span>
        <span>//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span>
        <span>if</span> <span>(</span>newCapacity <span>-</span> MAX_ARRAY_SIZE <span>></span> <span>0</span><span>)</span>
            newCapacity <span>=</span> <span>hugeCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>
        <span>// minCapacity is usually close to size, so this is a win:</span>
        elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> newCapacity<span>)</span><span>;</span>
    <span>}</span>
    <span>//比较minCapacity和 MAX_ARRAY_SIZE</span>
    <span>private</span> <span>static</span> <span>int</span> <span>hugeCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>minCapacity <span>&lt;</span> <span>0</span><span>)</span> <span>// overflow</span>
            <span>throw</span> <span>new</span> <span>OutOfMemoryError</span><span>(</span><span>)</span><span>;</span>
        <span>return</span> <span>(</span>minCapacity <span>></span> MAX_ARRAY_SIZE<span>)</span> <span>?</span>
            <span>Integer</span><span>.</span>MAX_VALUE <span>:</span>
            MAX_ARRAY_SIZE<span>;</span>
    <span>}</span>

    <span>/**
     *返回此列表中的元素数。
     */</span>
    <span>public</span> <span>int</span> <span>size</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> size<span>;</span>
    <span>}</span>

    <span>/**
     * 如果此列表不包含元素，则返回 true 。
     */</span>
    <span>public</span> <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span> <span>{</span>
        <span>//注意=和==的区别</span>
        <span>return</span> size <span>==</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>/**
     * 如果此列表包含指定的元素，则返回true 。
     */</span>
    <span>public</span> <span>boolean</span> <span>contains</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>
        <span>//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span>
        <span>return</span> <span>indexOf</span><span>(</span>o<span>)</span> <span>>=</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>/**
     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1
     */</span>
    <span>public</span> <span>int</span> <span>indexOf</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>o <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span>
                <span>if</span> <span>(</span>elementData<span>[</span>i<span>]</span><span>==</span><span>null</span><span>)</span>
                    <span>return</span> i<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span>
                <span>//equals()方法比较</span>
                <span>if</span> <span>(</span>o<span>.</span><span>equals</span><span>(</span>elementData<span>[</span>i<span>]</span><span>)</span><span>)</span>
                    <span>return</span> i<span>;</span>
        <span>}</span>
        <span>return</span> <span>-</span><span>1</span><span>;</span>
    <span>}</span>

    <span>/**
     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.
     */</span>
    <span>public</span> <span>int</span> <span>lastIndexOf</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>o <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> size<span>-</span><span>1</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span>
                <span>if</span> <span>(</span>elementData<span>[</span>i<span>]</span><span>==</span><span>null</span><span>)</span>
                    <span>return</span> i<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> size<span>-</span><span>1</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span>
                <span>if</span> <span>(</span>o<span>.</span><span>equals</span><span>(</span>elementData<span>[</span>i<span>]</span><span>)</span><span>)</span>
                    <span>return</span> i<span>;</span>
        <span>}</span>
        <span>return</span> <span>-</span><span>1</span><span>;</span>
    <span>}</span>

    <span>/**
     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）
     */</span>
    <span>public</span> <span>Object</span> <span>clone</span><span>(</span><span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
            <span>ArrayList</span><span><span>&lt;</span><span>?</span><span>></span></span> v <span>=</span> <span>(</span><span>ArrayList</span><span><span>&lt;</span><span>?</span><span>></span></span><span>)</span> <span>super</span><span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>
            <span>//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span>
            v<span>.</span>elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>)</span><span>;</span>
            v<span>.</span>modCount <span>=</span> <span>0</span><span>;</span>
            <span>return</span> v<span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>CloneNotSupportedException</span> e<span>)</span> <span>{</span>
            <span>// 这不应该发生，因为我们是可以克隆的</span>
            <span>throw</span> <span>new</span> <span>InternalError</span><span>(</span>e<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>/**
     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。
     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。
     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。
     */</span>
    <span>public</span> <span>Object</span><span>[</span><span>]</span> <span>toArray</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;
     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。
     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。
     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。
     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）
     */</span>
    <span>@SuppressWarnings</span><span>(</span><span>"unchecked"</span><span>)</span>
    <span>public</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span><span>[</span><span>]</span> <span>toArray</span><span>(</span><span>T</span><span>[</span><span>]</span> a<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>a<span>.</span>length <span>&lt;</span> size<span>)</span>
            <span>// 新建一个运行时类型的数组，但是ArrayList数组的内容</span>
            <span>return</span> <span>(</span><span>T</span><span>[</span><span>]</span><span>)</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>,</span> a<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>//调用System提供的arraycopy()方法实现数组之间的复制</span>
        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> <span>0</span><span>,</span> a<span>,</span> <span>0</span><span>,</span> size<span>)</span><span>;</span>
        <span>if</span> <span>(</span>a<span>.</span>length <span>></span> size<span>)</span>
            a<span>[</span>size<span>]</span> <span>=</span> <span>null</span><span>;</span>
        <span>return</span> a<span>;</span>
    <span>}</span>

    <span>// Positional Access Operations</span>

    <span>@SuppressWarnings</span><span>(</span><span>"unchecked"</span><span>)</span>
    <span>E</span> <span>elementData</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>return</span> <span>(</span><span>E</span><span>)</span> elementData<span>[</span>index<span>]</span><span>;</span>
    <span>}</span>

    <span>/**
     * 返回此列表中指定位置的元素。
     */</span>
    <span>public</span> <span>E</span> <span>get</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>rangeCheck</span><span>(</span>index<span>)</span><span>;</span>

        <span>return</span> <span>elementData</span><span>(</span>index<span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 用指定的元素替换此列表中指定位置的元素。
     */</span>
    <span>public</span> <span>E</span> <span>set</span><span>(</span><span>int</span> index<span>,</span> <span>E</span> element<span>)</span> <span>{</span>
        <span>//对index进行界限检查</span>
        <span>rangeCheck</span><span>(</span>index<span>)</span><span>;</span>

        <span>E</span> oldValue <span>=</span> <span>elementData</span><span>(</span>index<span>)</span><span>;</span>
        elementData<span>[</span>index<span>]</span> <span>=</span> element<span>;</span>
        <span>//返回原来在这个位置的元素</span>
        <span>return</span> oldValue<span>;</span>
    <span>}</span>

    <span>/**
     * 将指定的元素追加到此列表的末尾。
     */</span>
    <span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>
        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  <span>// Increments modCount!!</span>
        <span>//这里看到ArrayList添加元素的实质就相当于为数组赋值</span>
        elementData<span>[</span>size<span>++</span><span>]</span> <span>=</span> e<span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>

    <span>/**
     * 在此列表中的指定位置插入指定的元素。
     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；
     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。
     */</span>
    <span>public</span> <span>void</span> <span>add</span><span>(</span><span>int</span> index<span>,</span> <span>E</span> element<span>)</span> <span>{</span>
        <span>rangeCheckForAdd</span><span>(</span>index<span>)</span><span>;</span>

        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  <span>// Increments modCount!!</span>
        <span>//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span>
        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>,</span> elementData<span>,</span> index <span>+</span> <span>1</span><span>,</span>
                         size <span>-</span> index<span>)</span><span>;</span>
        elementData<span>[</span>index<span>]</span> <span>=</span> element<span>;</span>
        size<span>++</span><span>;</span>
    <span>}</span>

    <span>/**
     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。
     */</span>
    <span>public</span> <span>E</span> <span>remove</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>rangeCheck</span><span>(</span>index<span>)</span><span>;</span>

        modCount<span>++</span><span>;</span>
        <span>E</span> oldValue <span>=</span> <span>elementData</span><span>(</span>index<span>)</span><span>;</span>

        <span>int</span> numMoved <span>=</span> size <span>-</span> index <span>-</span> <span>1</span><span>;</span>
        <span>if</span> <span>(</span>numMoved <span>></span> <span>0</span><span>)</span>
            <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>+</span><span>1</span><span>,</span> elementData<span>,</span> index<span>,</span>
                             numMoved<span>)</span><span>;</span>
        elementData<span>[</span><span>--</span>size<span>]</span> <span>=</span> <span>null</span><span>;</span> <span>// clear to let GC do its work</span>
      <span>//从列表中删除的元素</span>
        <span>return</span> oldValue<span>;</span>
    <span>}</span>

    <span>/**
     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。
     *返回true，如果此列表包含指定的元素
     */</span>
    <span>public</span> <span>boolean</span> <span>remove</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>o <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> index <span>=</span> <span>0</span><span>;</span> index <span>&lt;</span> size<span>;</span> index<span>++</span><span>)</span>
                <span>if</span> <span>(</span>elementData<span>[</span>index<span>]</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
                    <span>fastRemove</span><span>(</span>index<span>)</span><span>;</span>
                    <span>return</span> <span>true</span><span>;</span>
                <span>}</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> index <span>=</span> <span>0</span><span>;</span> index <span>&lt;</span> size<span>;</span> index<span>++</span><span>)</span>
                <span>if</span> <span>(</span>o<span>.</span><span>equals</span><span>(</span>elementData<span>[</span>index<span>]</span><span>)</span><span>)</span> <span>{</span>
                    <span>fastRemove</span><span>(</span>index<span>)</span><span>;</span>
                    <span>return</span> <span>true</span><span>;</span>
                <span>}</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>

    <span>/*
     * Private remove method that skips bounds checking and does not
     * return the value removed.
     */</span>
    <span>private</span> <span>void</span> <span>fastRemove</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        modCount<span>++</span><span>;</span>
        <span>int</span> numMoved <span>=</span> size <span>-</span> index <span>-</span> <span>1</span><span>;</span>
        <span>if</span> <span>(</span>numMoved <span>></span> <span>0</span><span>)</span>
            <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>+</span><span>1</span><span>,</span> elementData<span>,</span> index<span>,</span>
                             numMoved<span>)</span><span>;</span>
        elementData<span>[</span><span>--</span>size<span>]</span> <span>=</span> <span>null</span><span>;</span> <span>// clear to let GC do its work</span>
    <span>}</span>

    <span>/**
     * 从列表中删除所有元素。
     */</span>
    <span>public</span> <span>void</span> <span>clear</span><span>(</span><span>)</span> <span>{</span>
        modCount<span>++</span><span>;</span>

        <span>// 把数组中所有的元素的值设为null</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span>
            elementData<span>[</span>i<span>]</span> <span>=</span> <span>null</span><span>;</span>

        size <span>=</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>/**
     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。
     */</span>
    <span>public</span> <span>boolean</span> <span>addAll</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>
        <span>Object</span><span>[</span><span>]</span> a <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> numNew <span>=</span> a<span>.</span>length<span>;</span>
        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> numNew<span>)</span><span>;</span>  <span>// Increments modCount</span>
        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>a<span>,</span> <span>0</span><span>,</span> elementData<span>,</span> size<span>,</span> numNew<span>)</span><span>;</span>
        size <span>+=</span> numNew<span>;</span>
        <span>return</span> numNew <span>!=</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>/**
     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。
     */</span>
    <span>public</span> <span>boolean</span> <span>addAll</span><span>(</span><span>int</span> index<span>,</span> <span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>
        <span>rangeCheckForAdd</span><span>(</span>index<span>)</span><span>;</span>

        <span>Object</span><span>[</span><span>]</span> a <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> numNew <span>=</span> a<span>.</span>length<span>;</span>
        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> numNew<span>)</span><span>;</span>  <span>// Increments modCount</span>

        <span>int</span> numMoved <span>=</span> size <span>-</span> index<span>;</span>
        <span>if</span> <span>(</span>numMoved <span>></span> <span>0</span><span>)</span>
            <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>,</span> elementData<span>,</span> index <span>+</span> numNew<span>,</span>
                             numMoved<span>)</span><span>;</span>

        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>a<span>,</span> <span>0</span><span>,</span> elementData<span>,</span> index<span>,</span> numNew<span>)</span><span>;</span>
        size <span>+=</span> numNew<span>;</span>
        <span>return</span> numNew <span>!=</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>/**
     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。
     *将任何后续元素移动到左侧（减少其索引）。
     */</span>
    <span>protected</span> <span>void</span> <span>removeRange</span><span>(</span><span>int</span> fromIndex<span>,</span> <span>int</span> toIndex<span>)</span> <span>{</span>
        modCount<span>++</span><span>;</span>
        <span>int</span> numMoved <span>=</span> size <span>-</span> toIndex<span>;</span>
        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> toIndex<span>,</span> elementData<span>,</span> fromIndex<span>,</span>
                         numMoved<span>)</span><span>;</span>

        <span>// clear to let GC do its work</span>
        <span>int</span> newSize <span>=</span> size <span>-</span> <span>(</span>toIndex<span>-</span>fromIndex<span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> newSize<span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            elementData<span>[</span>i<span>]</span> <span>=</span> <span>null</span><span>;</span>
        <span>}</span>
        size <span>=</span> newSize<span>;</span>
    <span>}</span>

    <span>/**
     * 检查给定的索引是否在范围内。
     */</span>
    <span>private</span> <span>void</span> <span>rangeCheck</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>index <span>>=</span> size<span>)</span>
            <span>throw</span> <span>new</span> <span>IndexOutOfBoundsException</span><span>(</span><span>outOfBoundsMsg</span><span>(</span>index<span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * add和addAll使用的rangeCheck的一个版本
     */</span>
    <span>private</span> <span>void</span> <span>rangeCheckForAdd</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>index <span>></span> size <span>||</span> index <span>&lt;</span> <span>0</span><span>)</span>
            <span>throw</span> <span>new</span> <span>IndexOutOfBoundsException</span><span>(</span><span>outOfBoundsMsg</span><span>(</span>index<span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 返回IndexOutOfBoundsException细节信息
     */</span>
    <span>private</span> <span>String</span> <span>outOfBoundsMsg</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>return</span> <span>"Index: "</span><span>+</span>index<span>+</span><span>", Size: "</span><span>+</span>size<span>;</span>
    <span>}</span>

    <span>/**
     * 从此列表中删除指定集合中包含的所有元素。
     */</span>
    <span>public</span> <span>boolean</span> <span>removeAll</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span><span>></span></span> c<span>)</span> <span>{</span>
        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>c<span>)</span><span>;</span>
        <span>//如果此列表被修改则返回true</span>
        <span>return</span> <span>batchRemove</span><span>(</span>c<span>,</span> <span>false</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 仅保留此列表中包含在指定集合中的元素。
     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。
     */</span>
    <span>public</span> <span>boolean</span> <span>retainAll</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span><span>></span></span> c<span>)</span> <span>{</span>
        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>c<span>)</span><span>;</span>
        <span>return</span> <span>batchRemove</span><span>(</span>c<span>,</span> <span>true</span><span>)</span><span>;</span>
    <span>}</span>


    <span>/**
     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。
     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。
     *返回的列表迭代器是fail-fast 。
     */</span>
    <span>public</span> <span>ListIterator</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>listIterator</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>index <span>&lt;</span> <span>0</span> <span>||</span> index <span>></span> size<span>)</span>
            <span>throw</span> <span>new</span> <span>IndexOutOfBoundsException</span><span>(</span><span>"Index: "</span><span>+</span>index<span>)</span><span>;</span>
        <span>return</span> <span>new</span> <span>ListItr</span><span>(</span>index<span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     *返回列表中的列表迭代器（按适当的顺序）。
     *返回的列表迭代器是fail-fast 。
     */</span>
    <span>public</span> <span>ListIterator</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>listIterator</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ListItr</span><span>(</span><span>0</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     *以正确的顺序返回该列表中的元素的迭代器。
     *返回的迭代器是fail-fast 。
     */</span>
    <span>public</span> <span>Iterator</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>iterator</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>Itr</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br><span>206</span><br><span>207</span><br><span>208</span><br><span>209</span><br><span>210</span><br><span>211</span><br><span>212</span><br><span>213</span><br><span>214</span><br><span>215</span><br><span>216</span><br><span>217</span><br><span>218</span><br><span>219</span><br><span>220</span><br><span>221</span><br><span>222</span><br><span>223</span><br><span>224</span><br><span>225</span><br><span>226</span><br><span>227</span><br><span>228</span><br><span>229</span><br><span>230</span><br><span>231</span><br><span>232</span><br><span>233</span><br><span>234</span><br><span>235</span><br><span>236</span><br><span>237</span><br><span>238</span><br><span>239</span><br><span>240</span><br><span>241</span><br><span>242</span><br><span>243</span><br><span>244</span><br><span>245</span><br><span>246</span><br><span>247</span><br><span>248</span><br><span>249</span><br><span>250</span><br><span>251</span><br><span>252</span><br><span>253</span><br><span>254</span><br><span>255</span><br><span>256</span><br><span>257</span><br><span>258</span><br><span>259</span><br><span>260</span><br><span>261</span><br><span>262</span><br><span>263</span><br><span>264</span><br><span>265</span><br><span>266</span><br><span>267</span><br><span>268</span><br><span>269</span><br><span>270</span><br><span>271</span><br><span>272</span><br><span>273</span><br><span>274</span><br><span>275</span><br><span>276</span><br><span>277</span><br><span>278</span><br><span>279</span><br><span>280</span><br><span>281</span><br><span>282</span><br><span>283</span><br><span>284</span><br><span>285</span><br><span>286</span><br><span>287</span><br><span>288</span><br><span>289</span><br><span>290</span><br><span>291</span><br><span>292</span><br><span>293</span><br><span>294</span><br><span>295</span><br><span>296</span><br><span>297</span><br><span>298</span><br><span>299</span><br><span>300</span><br><span>301</span><br><span>302</span><br><span>303</span><br><span>304</span><br><span>305</span><br><span>306</span><br><span>307</span><br><span>308</span><br><span>309</span><br><span>310</span><br><span>311</span><br><span>312</span><br><span>313</span><br><span>314</span><br><span>315</span><br><span>316</span><br><span>317</span><br><span>318</span><br><span>319</span><br><span>320</span><br><span>321</span><br><span>322</span><br><span>323</span><br><span>324</span><br><span>325</span><br><span>326</span><br><span>327</span><br><span>328</span><br><span>329</span><br><span>330</span><br><span>331</span><br><span>332</span><br><span>333</span><br><span>334</span><br><span>335</span><br><span>336</span><br><span>337</span><br><span>338</span><br><span>339</span><br><span>340</span><br><span>341</span><br><span>342</span><br><span>343</span><br><span>344</span><br><span>345</span><br><span>346</span><br><span>347</span><br><span>348</span><br><span>349</span><br><span>350</span><br><span>351</span><br><span>352</span><br><span>353</span><br><span>354</span><br><span>355</span><br><span>356</span><br><span>357</span><br><span>358</span><br><span>359</span><br><span>360</span><br><span>361</span><br><span>362</span><br><span>363</span><br><span>364</span><br><span>365</span><br><span>366</span><br><span>367</span><br><span>368</span><br><span>369</span><br><span>370</span><br><span>371</span><br><span>372</span><br><span>373</span><br><span>374</span><br><span>375</span><br><span>376</span><br><span>377</span><br><span>378</span><br><span>379</span><br><span>380</span><br><span>381</span><br><span>382</span><br><span>383</span><br><span>384</span><br><span>385</span><br><span>386</span><br><span>387</span><br><span>388</span><br><span>389</span><br><span>390</span><br><span>391</span><br><span>392</span><br><span>393</span><br><span>394</span><br><span>395</span><br><span>396</span><br><span>397</span><br><span>398</span><br><span>399</span><br><span>400</span><br><span>401</span><br><span>402</span><br><span>403</span><br><span>404</span><br><span>405</span><br><span>406</span><br><span>407</span><br><span>408</span><br><span>409</span><br><span>410</span><br><span>411</span><br><span>412</span><br><span>413</span><br><span>414</span><br><span>415</span><br><span>416</span><br><span>417</span><br><span>418</span><br><span>419</span><br><span>420</span><br><span>421</span><br><span>422</span><br><span>423</span><br><span>424</span><br><span>425</span><br><span>426</span><br><span>427</span><br><span>428</span><br><span>429</span><br><span>430</span><br><span>431</span><br><span>432</span><br><span>433</span><br><span>434</span><br><span>435</span><br><span>436</span><br><span>437</span><br><span>438</span><br><span>439</span><br><span>440</span><br><span>441</span><br><span>442</span><br><span>443</span><br><span>444</span><br><span>445</span><br><span>446</span><br><span>447</span><br><span>448</span><br><span>449</span><br><span>450</span><br><span>451</span><br><span>452</span><br><span>453</span><br><span>454</span><br><span>455</span><br><span>456</span><br><span>457</span><br><span>458</span><br><span>459</span><br><span>460</span><br><span>461</span><br><span>462</span><br><span>463</span><br><span>464</span><br><span>465</span><br><span>466</span><br><span>467</span><br><span>468</span><br><span>469</span><br><span>470</span><br><span>471</span><br><span>472</span><br><span>473</span><br><span>474</span><br><span>475</span><br><span>476</span><br><span>477</span><br><span>478</span><br><span>479</span><br><span>480</span><br><span>481</span><br><span>482</span><br><span>483</span><br><span>484</span><br><span>485</span><br><span>486</span><br><span>487</span><br><span>488</span><br><span>489</span><br><span>490</span><br><span>491</span><br><span>492</span><br><span>493</span><br><span>494</span><br><span>495</span><br><span>496</span><br><span>497</span><br><span>498</span><br><span>499</span><br><span>500</span><br><span>501</span><br><span>502</span><br><span>503</span><br><span>504</span><br></div></div><h2 id="collection-子接口之-set"> Collection 子接口之 Set</h2>
<h3 id="comparable-和-comparator-的区别"> comparable 和 Comparator 的区别</h3>
<ul>
<li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li>
<li><code>comparator</code>接口实际上是出自 <code>java.util</code> 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li>
</ul>
<p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写<code>compareTo()</code>方法和使用自制的<code>Comparator</code>方法或者以两个 <code>Comparator</code> 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code>.</p>
<p>Comparator 定制排序</p>
<div><pre><code>    <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> arrayList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    arrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>
    arrayList<span>.</span><span>add</span><span>(</span><span>3</span><span>)</span><span>;</span>
    arrayList<span>.</span><span>add</span><span>(</span><span>3</span><span>)</span><span>;</span>
    arrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>5</span><span>)</span><span>;</span>
    arrayList<span>.</span><span>add</span><span>(</span><span>7</span><span>)</span><span>;</span>
    arrayList<span>.</span><span>add</span><span>(</span><span>4</span><span>)</span><span>;</span>
    arrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>9</span><span>)</span><span>;</span>
    arrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>7</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"原始数组:"</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>
    <span>// void reverse(List list)：反转</span>
    <span>Collections</span><span>.</span><span>reverse</span><span>(</span>arrayList<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Collections.reverse(arrayList):"</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>

    <span>// void sort(List list),按自然排序的升序排序</span>
    <span>Collections</span><span>.</span><span>sort</span><span>(</span>arrayList<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Collections.sort(arrayList):"</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>
    <span>// 定制排序的用法</span>
    <span>Collections</span><span>.</span><span>sort</span><span>(</span>arrayList<span>,</span> <span>new</span> <span>Comparator</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span> <span>{</span>

        <span>@Override</span>
        <span>public</span> <span>int</span> <span>compare</span><span>(</span><span>Integer</span> o1<span>,</span> <span>Integer</span> o2<span>)</span> <span>{</span>
            <span>return</span> o2<span>.</span><span>compareTo</span><span>(</span>o1<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"定制排序后："</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>Output:</p>
<div><pre><code>原始数组<span>:</span>
<span>[</span><span>-</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>-</span><span>5</span><span>,</span> <span>7</span><span>,</span> <span>4</span><span>,</span> <span>-</span><span>9</span><span>,</span> <span>-</span><span>7</span><span>]</span>
<span>Collections</span><span>.</span><span>reverse</span><span>(</span>arrayList<span>)</span><span>:</span>
<span>[</span><span>-</span><span>7</span><span>,</span> <span>-</span><span>9</span><span>,</span> <span>4</span><span>,</span> <span>7</span><span>,</span> <span>-</span><span>5</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>-</span><span>1</span><span>]</span>
<span>Collections</span><span>.</span><span>sort</span><span>(</span>arrayList<span>)</span><span>:</span>
<span>[</span><span>-</span><span>9</span><span>,</span> <span>-</span><span>7</span><span>,</span> <span>-</span><span>5</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>7</span><span>]</span>
定制排序后：
<span>[</span><span>7</span><span>,</span> <span>4</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>-</span><span>5</span><span>,</span> <span>-</span><span>7</span><span>,</span> <span>-</span><span>9</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>重写 compareTo 方法实现按年龄来排序</p>
<div><pre><code><span>// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span>
<span>// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span>
<span>// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span>
<span>public</span>  <span>class</span> <span>Person</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Person</span><span>></span></span> <span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>int</span> age<span>;</span>

    <span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> age<span>)</span> <span>{</span>
        <span>super</span><span>(</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> age<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setAge</span><span>(</span><span>int</span> age<span>)</span> <span>{</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>

    <span>/**
     * T重写compareTo方法实现按年龄来排序
     */</span>
    <span>@Override</span>
    <span>public</span> <span>int</span> <span>compareTo</span><span>(</span><span>Person</span> o<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>this</span><span>.</span>age <span>></span> o<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>1</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span><span>this</span><span>.</span>age <span>&lt;</span> o<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>-</span><span>1</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>TreeMap</span><span><span>&lt;</span><span>Person</span><span>,</span> <span>String</span><span>></span></span> pdata <span>=</span> <span>new</span> <span>TreeMap</span><span><span>&lt;</span><span>Person</span><span>,</span> <span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    pdata<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>"张三"</span><span>,</span> <span>30</span><span>)</span><span>,</span> <span>"zhangsan"</span><span>)</span><span>;</span>
    pdata<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>"李四"</span><span>,</span> <span>20</span><span>)</span><span>,</span> <span>"lisi"</span><span>)</span><span>;</span>
    pdata<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>"王五"</span><span>,</span> <span>10</span><span>)</span><span>,</span> <span>"wangwu"</span><span>)</span><span>;</span>
    pdata<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>"小红"</span><span>,</span> <span>5</span><span>)</span><span>,</span> <span>"xiaohong"</span><span>)</span><span>;</span>
    <span>// 得到key的值的同时得到key所对应的值</span>
    <span>Set</span><span><span>&lt;</span><span>Person</span><span>></span></span> keys <span>=</span> pdata<span>.</span><span>keySet</span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>Person</span> key <span>:</span> keys<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>key<span>.</span><span>getAge</span><span>(</span><span>)</span> <span>+</span> <span>"-"</span> <span>+</span> key<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>

    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>Output：</p>
<div><pre><code><span>5</span><span>-</span>小红
<span>10</span><span>-</span>王五
<span>20</span><span>-</span>李四
<span>30</span><span>-</span>张三
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="无序性和不可重复性的含义是什么"> 无序性和不可重复性的含义是什么</h3>
<p>1、什么是无序性？无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</p>
<p>2、什么是不可重复性？不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。</p>
<h3 id="比较-hashset、linkedhashset-和-treeset-三者的异同"> 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3>
<ul>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 <code>FIFO</code>。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
<li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 <code>FIFO</code> 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li>
</ul>
<h2 id="collection-子接口之-queue"> Collection 子接口之 Queue</h2>
<h3 id="queue-与-deque-的区别"> Queue 与 Deque 的区别</h3>
<p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p>
<p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p>
<table>
<thead>
<tr>
<th>Queue</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入队尾</td>
<td>add(E e)</td>
<td>offer(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody>
</table>
<p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p>
<p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p>
<table>
<thead>
<tr>
<th>Deque</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入队首</td>
<td>addFirst(E e)</td>
<td>offerFirst(E e)</td>
</tr>
<tr>
<td>插入队尾</td>
<td>addLast(E e)</td>
<td>offerLast(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>removeFirst()</td>
<td>pollFirst()</td>
</tr>
<tr>
<td>删除队尾</td>
<td>removeLast()</td>
<td>pollLast()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>getFirst()</td>
<td>peekFirst()</td>
</tr>
<tr>
<td>查询队尾元素</td>
<td>getLast()</td>
<td>peekLast()</td>
</tr>
</tbody>
</table>
<p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p>
<h3 id="arraydeque-与-linkedlist-的区别"> ArrayDeque 与 LinkedList 的区别</h3>
<p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p>
<ul>
<li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li>
<li><code>ArrayDeque</code> <strong>不支持存储 NULL 数据</strong>，但 <code>LinkedList</code> 支持。</li>
<li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li>
<li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span>。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li>
</ul>
<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p>
<h3 id="priorityqueue"> PriorityQueue</h3>
<p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p>
<p>这里列举其相关的一些要点：</p>
<ul>
<li><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li>
<li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.01968em;">l</span><span>o</span><span style="margin-right:0.03588em;">g</span><span>n</span><span>)</span></span></span></span> 的时间复杂度内插入元素和删除堆顶元素。</li>
<li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li>
<li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li>
</ul>
<p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等，所以需要会熟练使用才行。</p>
<h2 id="map-接口"> Map 接口</h2>
<h3 id="hashmap-和-hashtable-的区别"> HashMap 和 Hashtable 的区别</h3>
<ol>
<li><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）</li>
<li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它</li>
<li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；<code>Hashtable</code> 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code></li>
<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>11</span></span></span></span>，之后每次扩充，容量变为原来的 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>2</span><span>n</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span>。<code>HashMap</code> 默认的初始化大小为 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>16</span></span></span></span>。之后每次扩充，容量变为原来的 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>2</span></span></span></span> 倍。② 创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>2</span></span></span></span> 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>2</span></span></span></span> 的幂作为哈希表的大小,后面会介绍到为什么是 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>2</span></span></span></span> 的幂次方。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>8</span></span></span></span>）（将链表转换成红黑树前会判断，如果当前数组的长度小于 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>64</span></span></span></span>，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。<code>Hashtable</code> 没有这样的机制。</li>
</ol>
<p><strong>HashMap 中带有初始容量的构造函数：</strong></p>
<div><pre><code><span>public</span> <span>HashMap</span><span>(</span><span>int</span> initialCapacity<span>,</span> <span>float</span> loadFactor<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>initialCapacity <span>&lt;</span> <span>0</span><span>)</span>
        <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>"Illegal initial capacity: "</span> <span>+</span>
                                            initialCapacity<span>)</span><span>;</span>
    <span>if</span> <span>(</span>initialCapacity <span>></span> MAXIMUM_CAPACITY<span>)</span>
        initialCapacity <span>=</span> MAXIMUM_CAPACITY<span>;</span>
    <span>if</span> <span>(</span>loadFactor <span>&lt;=</span> <span>0</span> <span>||</span> <span>Float</span><span>.</span><span>isNaN</span><span>(</span>loadFactor<span>)</span><span>)</span>
        <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>"Illegal load factor: "</span> <span>+</span>
                                            loadFactor<span>)</span><span>;</span>
    <span>this</span><span>.</span>loadFactor <span>=</span> loadFactor<span>;</span>
    <span>this</span><span>.</span>threshold <span>=</span> <span>tableSizeFor</span><span>(</span>initialCapacity<span>)</span><span>;</span>
<span>}</span>
    <span>public</span> <span>HashMap</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>
    <span>this</span><span>(</span>initialCapacity<span>,</span> DEFAULT_LOAD_FACTOR<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>下面这个方法保证了 <code>HashMap</code> 总是使用 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>2</span></span></span></span> 的幂作为哈希表的大小。</p>
<div><pre><code>    <span>/**
     * Returns a power of two size for the given target capacity.
     */</span>
    <span>static</span> <span>final</span> <span>int</span> <span>tableSizeFor</span><span>(</span><span>int</span> cap<span>)</span> <span>{</span>
        <span>int</span> n <span>=</span> cap <span>-</span> <span>1</span><span>;</span>
        n <span>|=</span> n <span>>>></span> <span>1</span><span>;</span>
        n <span>|=</span> n <span>>>></span> <span>2</span><span>;</span>
        n <span>|=</span> n <span>>>></span> <span>4</span><span>;</span>
        n <span>|=</span> n <span>>>></span> <span>8</span><span>;</span>
        n <span>|=</span> n <span>>>></span> <span>16</span><span>;</span>
        <span>return</span> <span>(</span>n <span>&lt;</span> <span>0</span><span>)</span> <span>?</span> <span>1</span> <span>:</span> <span>(</span>n <span>>=</span> MAXIMUM_CAPACITY<span>)</span> <span>?</span> MAXIMUM_CAPACITY <span>:</span> n <span>+</span> <span>1</span><span>;</span>
    <span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>详解如下：</p>
<p>先来分析有关n位操作部分：先来假设n的二进制为01xxx...xxx。接着</p>
<p>对n右移1位：001xx...xxx，再位或：011xx...xxx</p>
<p>对n右移2为：00011...xxx，再位或：01111...xxx</p>
<p>此时前面已经有四个1了，再右移4位且位或可得8个1</p>
<p>同理，有8个1，右移8位肯定会让后八位也为1。</p>
<p><strong>综上可得，该算法让最高位的1后面的位全变为1。</strong></p>
<p>最后再让结果n+1，即得到了2的整数次幂的值了。</p>
<p>现在回来看看第一条语句：</p>
<div><pre><code><span>int</span> n <span>=</span> cap <span>-</span> <span>1</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>让<code>cap-1</code>再赋值给<code>n</code>的目的是另找到的目标值大于或等于原值。例如二进制1000，十进制数值为8。如果不对它减1而直接操作，将得到答案10000，即16。显然不是结果。减1后二进制为111，再进行操作则会得到原来的数值1000，即8。</p>
<h3 id="hashmap-和-hashset-区别"> HashMap 和 HashSet 区别</h3>
<p><code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p>
<table>
<thead>
<tr>
<th>HashMap</th>
<th>HashSet</th>
</tr>
</thead>
<tbody>
<tr>
<td>实现Map接口</td>
<td>实现Set接口</td>
</tr>
<tr>
<td>存储键值对</td>
<td>仅存储对象</td>
</tr>
<tr>
<td>调用put()向map中添加元素</td>
<td>调用add()方法向Set中添加元素</td>
</tr>
<tr>
<td>HashMap使用(Key)计算hashcode</td>
<td>HashSet使用成员对象来计算hashcode，对于两个对象来说hashcode可能相同，所以equals() 方法用来判断对象的相等性</td>
</tr>
</tbody>
</table>
<h3 id="hashmap-和-treemap-区别"> HashMap 和 TreeMap 区别</h3>
<p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p>
<p><img src="https://javaguide.cn/assets/img/TreeMap继承结构.d58c3708.png" alt="" loading="lazy"></p>
<p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p>
<p>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 <code>key</code> 的升序排序，不过我们也可以指定排序的比较器。示例代码如下：</p>
<div><pre><code><span>/**
 * @author shuang.kou
 * @createTime 2020年06月15日 17:02:00
 */</span>
<span>public</span> <span>class</span> <span>Person</span> <span>{</span>
    <span>private</span> <span>Integer</span> age<span>;</span>

    <span>public</span> <span>Person</span><span>(</span><span>Integer</span> age<span>)</span> <span>{</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>

    <span>public</span> <span>Integer</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> age<span>;</span>
    <span>}</span>


    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>TreeMap</span><span><span>&lt;</span><span>Person</span><span>,</span> <span>String</span><span>></span></span> treeMap <span>=</span> <span>new</span> <span>TreeMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>new</span> <span>Comparator</span><span><span>&lt;</span><span>Person</span><span>></span></span><span>(</span><span>)</span> <span>{</span>
            <span>@Override</span>
            <span>public</span> <span>int</span> <span>compare</span><span>(</span><span>Person</span> person1<span>,</span> <span>Person</span> person2<span>)</span> <span>{</span>
                <span>int</span> num <span>=</span> person1<span>.</span><span>getAge</span><span>(</span><span>)</span> <span>-</span> person2<span>.</span><span>getAge</span><span>(</span><span>)</span><span>;</span>
                <span>return</span> <span>Integer</span><span>.</span><span>compare</span><span>(</span>num<span>,</span> <span>0</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>)</span><span>;</span>
        treeMap<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>3</span><span>)</span><span>,</span> <span>"person1"</span><span>)</span><span>;</span>
        treeMap<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>18</span><span>)</span><span>,</span> <span>"person2"</span><span>)</span><span>;</span>
        treeMap<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>35</span><span>)</span><span>,</span> <span>"person3"</span><span>)</span><span>;</span>
        treeMap<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>16</span><span>)</span><span>,</span> <span>"person4"</span><span>)</span><span>;</span>
        treeMap<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>forEach</span><span>(</span>personStringEntry <span>-></span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>personStringEntry<span>.</span><span>getValue</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><p>输出：</p>
<div><pre><code>person1
person4
person2
person3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>可以看出，<code>TreeMap</code> 中的元素已经是按照 <code>Person</code> 的 <code>age</code> 字段的升序来排列了。</p>
<p>上面，我们是通过传入匿名内部类的方式实现的，你可以将代码替换成 <code>Lambda</code> 表达式实现的方式：</p>
<div><pre><code><span>TreeMap</span><span><span>&lt;</span><span>Person</span><span>,</span> <span>String</span><span>></span></span> treeMap <span>=</span> <span>new</span> <span>TreeMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>(</span>person1<span>,</span> person2<span>)</span> <span>-></span> <span>{</span>
  <span>int</span> num <span>=</span> person1<span>.</span><span>getAge</span><span>(</span><span>)</span> <span>-</span> person2<span>.</span><span>getAge</span><span>(</span><span>)</span><span>;</span>
  <span>return</span> <span>Integer</span><span>.</span><span>compare</span><span>(</span>num<span>,</span> <span>0</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>
<p>关于升序降序的理解，<code>person1.getAge() - person2.getAge() &lt; 0</code>,<code>person1.getAge() &lt; person2.getAge()</code>，所以小的排前面，故为升序。</p>
</blockquote>
<p>综上，相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</p>
<h3 id="hashset-如何检查重复"> HashSet 如何检查重复</h3>
<p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>
<p>在openjdk8中，<code>HashSet</code>的<code>add()</code>方法只是简单的调用了<code>HashMap</code>的<code>put()</code>方法，并且判断了一下返回值以确保是否有重复元素。直接看一下<code>HashSet</code>中的源码：</p>
<div><pre><code><span>// Returns: true if this set did not already contain the specified element</span>
<span>// 返回值：当set中没有包含add的元素时返回真</span>
<span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>
        <span>return</span> map<span>.</span><span>put</span><span>(</span>e<span>,</span> PRESENT<span>)</span><span>==</span><span>null</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>而在HashMap的putVal()方法中也能看到如下说明：</p>
<div><pre><code><span>// Returns : previous value, or null if none</span>
<span>// 返回值：如果插入位置没有元素返回null，否则返回上一个元素</span>
<span>final</span> <span>V</span> <span>putVal</span><span>(</span><span>int</span> hash<span>,</span> <span>K</span> key<span>,</span> <span>V</span> value<span>,</span> <span>boolean</span> onlyIfAbsent<span>,</span>
                   <span>boolean</span> evict<span>)</span> <span>{</span>
<span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>也就是说，在openjdk8中，实际上无论<code>HashSet</code>中是否已经存在了某元素，<code>HashSet</code>都会直接插入，只是会在<code>add()</code>方法的返回值处告诉我们插入前是否存在相同元素。</p>
<p><strong>hashCode()与 equals() 的相关规定：</strong></p>
<ol>
<li>如果两个对象相等，则 <code>hashcode</code> 一定也是相同的</li>
<li>两个对象相等,对两个 <code>equals()</code> 方法返回 true</li>
<li>两个对象有相同的 <code>hashcode</code> 值，它们也不一定是相等的</li>
<li>综上，<code>equals()</code> 方法被覆盖过，则 <code>hashCode()</code> 方法也必须被覆盖</li>
</ol>
<h3 id="hashmap-的底层实现"> HashMap 的底层实现</h3>
<p>JDK1.8 之前</p>
<p>JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p>
<p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p>
<p>JDK 1.8 HashMap 的 hash 方法源码:</p>
<p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>
<div><pre><code><span>static</span> <span>final</span> <span>int</span> <span>hash</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>
    <span>int</span> h<span>;</span>
    <span>// key.hashCode()：返回散列值也就是hashcode</span>
    <span>// ^ ：按位异或</span>
    <span>// >>>:无符号右移，忽略符号位，空位都以0补齐</span>
    <span>return</span> <span>(</span>key <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>(</span>h <span>=</span> key<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>16</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p>
<div><pre><code><span>static</span> <span>int</span> <span>hash</span><span>(</span><span>int</span> h<span>)</span> <span>{</span>
    <span>// This function ensures that hashCodes that differ only by</span>
    <span>// constant multiples at each bit position have a bounded</span>
    <span>// number of collisions (approximately 8 at default load factor).</span>

    h <span>^=</span> <span>(</span>h <span>>>></span> <span>20</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>12</span><span>)</span><span>;</span>
    <span>return</span> h <span>^</span> <span>(</span>h <span>>>></span> <span>7</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>4</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>
<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p><img src="https://javaguide.cn/assets/img/jdk1.8之前的内部结构-HashMap.7cb759fd.png" alt="" loading="lazy"></p>
<p>JDK1.8 之后</p>
<p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<p><img src="https://javaguide.cn/assets/img/jdk1.8之后的内部结构-HashMap.137a1130.png" alt="" loading="lazy"></p>
<blockquote>
<p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p>
</blockquote>
<h3 id="hashmap-的长度为什么是-2-的幂次方"> HashMap 的长度为什么是 2 的幂次方</h3>
<p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。</p>
<p><strong>这个算法应该如何设计呢？</strong></p>
<p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</strong></p>
<h3 id="hashmap-多线程操作导致死循环问题"> HashMap 多线程操作导致死循环问题</h3>
<p>主要原因在于并发下的 Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p>
<p>详情：<a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener noreferrer">https://coolshell.cn/articles/9606.html</a></p>
<h3 id="hashmap-遍历方式"> HashMap 遍历方式</h3>
<h4 id="_1-迭代器-entryset"> 1.迭代器 EntrySet</h4>
<div><pre><code><span>public</span> <span>class</span> <span>HashMapTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 创建并赋值 HashMap</span>
        <span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span>(</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>1</span><span>,</span> <span>"Java"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>2</span><span>,</span> <span>"JDK"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>3</span><span>,</span> <span>"Spring Framework"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>4</span><span>,</span> <span>"MyBatis framework"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>5</span><span>,</span> <span>"Java中文社群"</span><span>)</span><span>;</span>
        <span>// 遍历</span>
        <span>Iterator</span><span><span>&lt;</span><span>Map<span>.</span>Entry</span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>></span><span>></span></span> iterator <span>=</span> map<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>
        <span>while</span> <span>(</span>iterator<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>></span></span> entry <span>=</span> iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>entry<span>.</span><span>getKey</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>entry<span>.</span><span>getValue</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h4 id="_2-迭代器-keyset"> 2.迭代器 KeySet</h4>
<div><pre><code><span>public</span> <span>class</span> <span>HashMapTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 创建并赋值 HashMap</span>
        <span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span>(</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>1</span><span>,</span> <span>"Java"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>2</span><span>,</span> <span>"JDK"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>3</span><span>,</span> <span>"Spring Framework"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>4</span><span>,</span> <span>"MyBatis framework"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>5</span><span>,</span> <span>"Java中文社群"</span><span>)</span><span>;</span>
        <span>// 遍历</span>
        <span>Iterator</span><span><span>&lt;</span><span>Integer</span><span>></span></span> iterator <span>=</span> map<span>.</span><span>keySet</span><span>(</span><span>)</span><span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>
        <span>while</span> <span>(</span>iterator<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>Integer</span> key <span>=</span> iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>key<span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>map<span>.</span><span>get</span><span>(</span>key<span>)</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h4 id="_3-foreach-entryset"> 3.ForEach EntrySet</h4>
<div><pre><code><span>public</span> <span>class</span> <span>HashMapTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 创建并赋值 HashMap</span>
        <span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span>(</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>1</span><span>,</span> <span>"Java"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>2</span><span>,</span> <span>"JDK"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>3</span><span>,</span> <span>"Spring Framework"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>4</span><span>,</span> <span>"MyBatis framework"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>5</span><span>,</span> <span>"Java中文社群"</span><span>)</span><span>;</span>
        <span>// 遍历</span>
        <span>for</span> <span>(</span><span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>></span></span> entry <span>:</span> map<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>entry<span>.</span><span>getKey</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>entry<span>.</span><span>getValue</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h4 id="_4-foreach-keyset"> 4.ForEach KeySet</h4>
<div><pre><code><span>public</span> <span>class</span> <span>HashMapTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 创建并赋值 HashMap</span>
        <span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span>(</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>1</span><span>,</span> <span>"Java"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>2</span><span>,</span> <span>"JDK"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>3</span><span>,</span> <span>"Spring Framework"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>4</span><span>,</span> <span>"MyBatis framework"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>5</span><span>,</span> <span>"Java中文社群"</span><span>)</span><span>;</span>
        <span>// 遍历</span>
        <span>for</span> <span>(</span><span>Integer</span> key <span>:</span> map<span>.</span><span>keySet</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>key<span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>map<span>.</span><span>get</span><span>(</span>key<span>)</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h4 id="_5-lambda"> 5.Lambda</h4>
<div><pre><code><span>public</span> <span>class</span> <span>HashMapTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 创建并赋值 HashMap</span>
        <span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span>(</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>1</span><span>,</span> <span>"Java"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>2</span><span>,</span> <span>"JDK"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>3</span><span>,</span> <span>"Spring Framework"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>4</span><span>,</span> <span>"MyBatis framework"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>5</span><span>,</span> <span>"Java中文社群"</span><span>)</span><span>;</span>
        <span>// 遍历</span>
        map<span>.</span><span>forEach</span><span>(</span><span>(</span>key<span>,</span> value<span>)</span> <span>-></span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>key<span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>value<span>)</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h4 id="_6-streams-api-单线程"> 6.Streams API 单线程</h4>
<div><pre><code><span>public</span> <span>class</span> <span>HashMapTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 创建并赋值 HashMap</span>
        <span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span>(</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>1</span><span>,</span> <span>"Java"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>2</span><span>,</span> <span>"JDK"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>3</span><span>,</span> <span>"Spring Framework"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>4</span><span>,</span> <span>"MyBatis framework"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>5</span><span>,</span> <span>"Java中文社群"</span><span>)</span><span>;</span>
        <span>// 遍历</span>
        map<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>forEach</span><span>(</span><span>(</span>entry<span>)</span> <span>-></span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>entry<span>.</span><span>getKey</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>entry<span>.</span><span>getValue</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h4 id="_7-streams-api-多线程"> 7.Streams API 多线程</h4>
<div><pre><code><span>public</span> <span>class</span> <span>HashMapTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 创建并赋值 HashMap</span>
        <span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span>(</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>1</span><span>,</span> <span>"Java"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>2</span><span>,</span> <span>"JDK"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>3</span><span>,</span> <span>"Spring Framework"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>4</span><span>,</span> <span>"MyBatis framework"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>5</span><span>,</span> <span>"Java中文社群"</span><span>)</span><span>;</span>
        <span>// 遍历</span>
        map<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>.</span><span>parallelStream</span><span>(</span><span>)</span><span>.</span><span>forEach</span><span>(</span><span>(</span>entry<span>)</span> <span>-></span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>entry<span>.</span><span>getKey</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>entry<span>.</span><span>getValue</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h4 id="性能分析"> 性能分析</h4>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsgeYXAj2Uedoee2ibmnwMYLeaIRiatjtU387kxT68GwIsktTRnlgIvQdQIrH9WZtenTCMl1sVF1JNOA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="" loading="lazy"></p>
<p>两个 <code>entrySet</code> 的性能相近，并且执行速度最快，接下来是 <code>stream</code> ，然后是两个 <code>keySet</code>，性能最差的是 lambda 。</p>
<p><strong>综上：</strong> 遍历<code>HashMap</code> 时，应尽量选用 <strong>forEachEntrySet</strong></p>
<h3 id="concurrenthashmap-和-hashtable-的区别"> ConcurrentHashMap 和 Hashtable 的区别</h3>
<p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表/红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 数组+链表 的形式，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li><strong>实现线程安全的方式（重要）：</strong> ① 在 JDK1.7 的时候，<code>ConcurrentHashMap</code>（分段锁） 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 对 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同一把锁) :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
<p><strong>两者的对比图：</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/HashTable全表锁.png" alt="" loading="lazy"></p>
<p><strong>JDK1.7 的 ConcurrentHashMap：</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ConcurrentHashMap分段锁.jpg" alt="" loading="lazy"></p>
<p><strong>JDK1.8 的 ConcurrentHashMap：</strong></p>
<p><img src="https://javaguide.cn/assets/img/java8_concurrenthashmap.457068ae.png" alt="" loading="lazy"></p>
<p>JDK1.8 的 <code>ConcurrentHashMap</code> 不再是 <code>Segment</code> 数组 + <code>HashEntry</code> 数组 + 链表，而是 <code>Node</code> 数组 + 链表 / 红黑树。不过，<code>Node</code> 只能用于链表的情况，红黑树的情况需要使用 <code>TreeNode</code>。当冲突链表达到一定长度时，链表会转换成红黑树。</p>
<h3 id="concurrenthashmap-线程安全的具体实现方式-底层具体实现"> ConcurrentHashMap 线程安全的具体实现方式/底层具体实现</h3>
<p><strong>JDK1.7</strong></p>
<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成。</p>
<p><code>Segment</code> 实现了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p>
<div><pre><code><span>static</span> <span>class</span> <span>Segment</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>extends</span> <span>ReentrantLock</span> <span>implements</span> <span>Serializable</span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组。<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。</p>
<p><strong>JDK1.8</strong></p>
<p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 CAS 和 <code>synchronized</code> 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>)</span></span></span></span>）转换为红黑树（寻址时间复杂度为 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.01968em;">l</span><span>o</span><span style="margin-right:0.03588em;">g</span><span>(</span><span style="margin-right:0.10903em;">N</span><span>))</span></span></span></span>）</p>
<p><code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p>
<h2 id="collections-工具类"> Collections 工具类</h2>
<p>Collections 工具类常用方法:</p>
<ol>
<li>排序</li>
<li>查找,替换操作</li>
<li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)</li>
</ol>
<h3 id="排序操作"> 排序操作</h3>
<div><pre><code><span>void</span> <span>reverse</span><span>(</span><span>List</span> list<span>)</span><span>//反转</span>
<span>void</span> <span>shuffle</span><span>(</span><span>List</span> list<span>)</span><span>//随机排序</span>
<span>void</span> <span>sort</span><span>(</span><span>List</span> list<span>)</span><span>//按自然排序的升序排序</span>
<span>void</span> <span>sort</span><span>(</span><span>List</span> list<span>,</span> <span>Comparator</span> c<span>)</span><span>//定制排序，由Comparator控制排序逻辑</span>
<span>void</span> <span>swap</span><span>(</span><span>List</span> list<span>,</span> <span>int</span> i <span>,</span> <span>int</span> j<span>)</span><span>//交换两个索引位置的元素</span>
<span>void</span> <span>rotate</span><span>(</span><span>List</span> list<span>,</span> <span>int</span> distance<span>)</span><span>//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="查找-替换操作"> 查找,替换操作</h3>
<div><pre><code><span>int</span> <span>binarySearch</span><span>(</span><span>List</span> list<span>,</span> <span>Object</span> key<span>)</span><span>//对List进行二分查找，返回索引，注意List必须是有序的</span>
<span>int</span> <span>max</span><span>(</span><span>Collection</span> coll<span>)</span><span>//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span>
<span>int</span> <span>max</span><span>(</span><span>Collection</span> coll<span>,</span> <span>Comparator</span> c<span>)</span><span>//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span>
<span>void</span> <span>fill</span><span>(</span><span>List</span> list<span>,</span> <span>Object</span> obj<span>)</span><span>//用指定的元素代替指定list中的所有元素</span>
<span>int</span> <span>frequency</span><span>(</span><span>Collection</span> c<span>,</span> <span>Object</span> o<span>)</span><span>//统计元素出现次数</span>
<span>int</span> <span>indexOfSubList</span><span>(</span><span>List</span> list<span>,</span> <span>List</span> target<span>)</span><span>//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)</span>
<span>boolean</span> <span>replaceAll</span><span>(</span><span>List</span> list<span>,</span> <span>Object</span> oldVal<span>,</span> <span>Object</span> newVal<span>)</span><span>//用新元素替换旧元素</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="同步控制"> 同步控制</h3>
<p><code>Collections</code> 提供了多个<code>synchronizedXxx()</code>方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。
我们知道 <code>HashSet</code>，<code>TreeSet</code>，<code>ArrayList</code>,<code>LinkedList</code>,<code>HashMap</code>,<code>TreeMap</code> 都是线程不安全的。<code>Collections</code> 提供了多个静态方法可以把他们包装成线程同步的集合。
<strong>最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合</strong></p>
<div><pre><code><span>synchronizedCollection</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>T</span><span>></span></span>  c<span>)</span> <span>//返回指定 collection 支持的同步（线程安全的）collection。</span>
<span>synchronizedList</span><span>(</span><span>List</span><span><span>&lt;</span><span>T</span><span>></span></span> list<span>)</span><span>//返回指定列表支持的同步（线程安全的）List。</span>
<span>synchronizedMap</span><span>(</span><span>Map</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> m<span>)</span> <span>//返回由指定映射支持的同步（线程安全的）Map。</span>
<span>synchronizedSet</span><span>(</span><span>Set</span><span><span>&lt;</span><span>T</span><span>></span></span> s<span>)</span> <span>//返回指定 set 支持的同步（线程安全的）set。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">面向对象与面向过程的区别</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <updated>2022-02-21T13:44:21.774Z</updated>
    <content type="html"><![CDATA[<h2 id="面向对象与面向过程的区别"> 面向对象与面向过程的区别</h2>
<ul>
<li><strong>面向过程 ：</strong> <strong>面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。<strong>但是，面向过程没有面向对象易维护、易复用、易扩展。</strong></li>
<li><strong>面向对象 ：面向对象易维护、易复用、易扩展。</strong> 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。<strong>但是，面向对象性能比面向过程低。</strong></li>
</ul>
<p><strong>注意：</strong> Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。</p>
<h2 id="成员变量与局部变量的区别有哪些"> 成员变量与局部变量的区别有哪些？</h2>
<p>1.从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public,private,static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</p>
<p>2.从变量在内存中的存储方式来看,如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</p>
<p>3.从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</p>
<p>4.从变量是否有默认值来看，成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p>
<h2 id="创建一个对象用什么运算符-对象实体与对象引用有何不同"> 创建一个对象用什么运算符?对象实体与对象引用有何不同?</h2>
<p>在Java中，万事万物都是对象。尽管一切都看作是对象，但是你操纵的却是一个对象的引用。在这里有一个很形象的比喻：你可以把车钥匙和车看作是一组对象引用和对象的组合。即使没有车，车钥匙也是一个独立存在的实体，也就是说，你有一个对象引用，但你不一定需要一个对象与之关联。</p>
<div><pre><code><span>Car</span> carKey<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>这里创建的只是引用，并非对象，但是如果想要使用这个引用时，会返回一个异常，告诉你需要一个对象来和这个引用进行关联，一种安全的做法是，在创建对象引用的同时把一个对象赋给它。</p>
<div><pre><code><span>Car</span> carKey <span>=</span> <span>new</span> <span>Car</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>在Java中，一旦创建了一个引用，就希望它能与一个新的对象进行关联，通常使用<code>new</code>操作符来实现这一目的。</p>
<p>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p>
<p>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p>
<h2 id="对象的相等与指向他们的引用相等-两者有什么不同"> 对象的相等与指向他们的引用相等,两者有什么不同?</h2>
<p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p>
<h2 id="一个类的构造方法的作用是什么-若一个类没有声明构造方法-该程序能正确执行吗-为什么"> 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?</h2>
<p>构造方法主要作用是完成对类对象的初始化工作。</p>
<p>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</p>
<h2 id="构造方法有哪些特点-是否可被-override"> 构造方法有哪些特点？是否可被 override?</h2>
<p><strong>特点：</strong></p>
<ul>
<li>1.名字与类名相同。</li>
<li>2.没有返回值，但不能用 void 声明构造函数。</li>
<li>3.生成类的对象时自动执行，无需调用。</li>
</ul>
<p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>
<h2 id="this和super"> this和super</h2>
<p>this和super都是Java中的关键字</p>
<p>this表示的是当前对象，this可以调用方法、调用属性和指向对象本身。</p>
<p>this在Java中的使用一般有三种：指向当前对象</p>
<div><pre><code><span>public</span> <span>class</span> <span>Apple</span><span>{</span>
    <span>int</span> i <span>=</span> <span>0</span><span>;</span>

    <span>Apple</span> <span>eatApple</span><span>(</span><span>)</span> <span>{</span>
        i<span>++</span><span>;</span>
        <span>return</span> <span>this</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Apple</span> apple <span>=</span> <span>new</span> <span>Apple</span><span>(</span><span>)</span><span>;</span>
        apple<span>.</span><span>eatApple</span><span>(</span><span>)</span><span>.</span><span>eatApple</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>一个<code>eatApple()</code>方法竟然可以调用多次，在后面还可以继续调用，这就很神奇了，为啥呢？其实就是<code>this</code>在作祟，我在<code>eatApple()</code>方法中加了一个<code>return this</code>的返回值，也就是说哪个对象调用<code>eatApple()</code>方法都能返回对象的自身。</p>
<p><code>this</code>还可以修饰属性，最常见的就是在构造方法中使用<code>this</code>，如下所示</p>
<div><pre><code><span>public</span> <span>class</span> <span>Apple</span><span>{</span>
    <span>private</span> <span>int</span> num<span>;</span>
    
    <span>public</span> <span>Apple</span><span>(</span><span>int</span> num<span>)</span> <span>{</span>
        <span>this</span><span>.</span>num <span>=</span> num<span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Apple</span> apple <span>=</span> <span>new</span> <span>Apple</span><span>(</span><span>10</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><code>main</code> 方法中传递了一个int值为10的参数，并把这个数量赋给了num全局变量。</p>
<p><code>this</code> 还可以和构造函数一起使用，充当一个全局关键字的效果</p>
<div><pre><code><span>class</span> <span>Apple</span><span>{</span>
    <span>private</span> <span>int</span> num<span>;</span>
    <span>private</span> <span>String</span> color<span>;</span>

    <span>public</span> <span>Apple</span><span>(</span><span>int</span> num<span>)</span> <span>{</span>
        <span>this</span><span>(</span>num<span>,</span> <span>"红色"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>Apple</span><span>(</span><span>int</span> num<span>,</span> <span>String</span> color<span>)</span> <span>{</span>
        <span>this</span><span>.</span>num <span>=</span> num<span>;</span>
        <span>this</span><span>.</span>color <span>=</span> color<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getNum</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> num<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getColor</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> color<span>;</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>Main</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Apple</span> apple <span>=</span> <span>new</span> <span>Apple</span><span>(</span><span>10</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>apple<span>.</span><span>getNum</span><span>(</span><span>)</span> <span>+</span> <span>"   "</span> <span>+</span> apple<span>.</span><span>getColor</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>输出：</p>
<div><pre><code>10   红色
</code></pre>
<div><span>1</span><br></div></div><p>你会发现上面这段代码使用的不是<code>this</code>,而是<code>this(参数)</code>。它相当于调用了其他构造方法，然后传递参数进去。<strong>这里值得注意的一点：this()必须放在构造函数的第一行，否则编译不通过。</strong></p>
<p>如果你把this理解为一个指向自身的一个引用，那么super就是指向父类的一个引用。super关键字和this一样，你可以使用<code>super.对象</code>来引用父类的成员。</p>
<div><pre><code><span>class</span> <span>Fruit</span> <span>{</span>
    <span>public</span> <span>int</span> num<span>;</span>
    <span>public</span> <span>String</span> color<span>;</span>

    <span>public</span> <span>void</span> <span>eat</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"eat Fruit"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>class</span> <span>Apple</span> <span>extends</span> <span>Fruit</span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>eat</span><span>(</span><span>)</span> <span>{</span>
        <span>super</span><span>.</span>num <span>=</span> <span>10</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"eat "</span> <span>+</span> num <span>+</span> <span>" Apple"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>Main</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Apple</span> apple <span>=</span> <span>new</span> <span>Apple</span><span>(</span><span>)</span><span>;</span>
        apple<span>.</span><span>eat</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>输出：</p>
<div><pre><code>eat 10 Apple
</code></pre>
<div><span>1</span><br></div></div><p>同样也可以使用<code>super(参数)</code>来调用父类的构造函数。</p>
<p>下面汇总了this关键字和super关键字的比较。</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>this</th>
<th>super</th>
</tr>
</thead>
<tbody>
<tr>
<td>调用方式</td>
<td>调用本类中的属性、构造函数、方法</td>
<td>调用父类中的属性、构造函数、方法</td>
</tr>
<tr>
<td>调用位置</td>
<td>构造函数第一行，其他可自行指定</td>
<td>构造函数第一行，其他可自行指定</td>
</tr>
<tr>
<td>调用次数</td>
<td>一个构造函数只能调用一次</td>
<td>一个构造函数只能调用一次</td>
</tr>
</tbody>
</table>
<h2 id="面向对象的三大特征"> 面向对象的三大特征</h2>
<h3 id="封装"> 封装</h3>
<p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。</p>
<p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p>
<p>要访问该类的代码和数据，必须通过严格的接口控制。</p>
<p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p>
<p>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p>
<p><strong>封装的优点：</strong></p>
<ul>
<li>1.良好的封装能够减少耦合</li>
<li>2.类内部的结构可以自由地修改</li>
<li>3.可以对成员变量进行更精确的控制</li>
<li>4.隐藏信息，实现细节</li>
</ul>
<p><strong>访问控制符</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>同一类</th>
<th>同一个包</th>
<th>不同包的子类</th>
<th>不同包</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>protected</td>
<td>yes</td>
<td>yes</td>
<td>yse(super)</td>
<td>no</td>
</tr>
<tr>
<td>default</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>private</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
</tbody>
</table>
<p><strong>1.public</strong></p>
<ul>
<li>可以修饰类,表示这个类可以被引入到任何地方使用</li>
<li>可以修饰属性和方法,表示这个属性和方法，可以在本类，本包其它类中，其它包的类中使用</li>
</ul>
<p><strong>2.protected</strong></p>
<ul>
<li>不能用来修饰类</li>
<li>可以修饰属性和方法,表示这个属性和方法，不能在其它包中访问，可以在本包中的其它类，可以在其它包的子类通过this/super访问</li>
</ul>
<p><strong>3.default</strong></p>
<p>不加任何访问控制符就表示default</p>
<ul>
<li>可以修饰类，表示该类只能在当前包中使用</li>
<li>可以修饰方法，属性，表示属性和方法 只能在当前包中的类里使用</li>
</ul>
<p><strong>4.private</strong></p>
<ul>
<li>可以修饰方法，属性，表示属性和方法 只能在当前类里使用</li>
</ul>
<p><strong>何为完全封装</strong></p>
<p>对所有的属性进行private隐藏，然后为这些属性提供get/set方法来存取访问</p>
<p><strong>get/set方法的写法</strong></p>
<ul>
<li>boolean值 setXxx, isXxx</li>
<li>其它类型  setXxx, getXxx</li>
</ul>
<h3 id="继承"> 继承</h3>
<p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ul>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有。</strong></li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（重写）。</li>
</ul>
<h3 id="多态"> 多态</h3>
<h4 id="_1-多态概述"> 1.多态概述</h4>
<p>1.面向对象程序设计的三大支柱是封装、继承和多态</p>
<p>2.多态就是对同一个对象，在<strong>不同</strong>时刻表现出来的<strong>不同</strong>形态</p>
<p>3.多态 <strong>现实意义</strong>    理解：</p>
<ul>
<li>电脑上的F1按键，当不打开任何文件点击F1显示的是系统的帮助文档，当打开word文档点击F1显示的是word文档的帮助，同一个按钮但是能实现不同的处理方式</li>
<li>现实中同一个事物通常会出现多种形态，比如说我自己，我在本质上是一个<strong>人</strong>，在学校里我是一个<strong>学生</strong>，这就是一种多态。</li>
<li>Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。</li>
</ul>
<p>4.多态意味着父类的变量可以指向子类对象。</p>
<p>5.多态的前提条件</p>
<ul>
<li>要有继承关系</li>
<li>要有方法重写</li>
<li>要有父类引用指向子类对象</li>
</ul>
<p>6.多态的定义格式</p>
<ul>
<li>父类类型 变量名=new 子类类型();</li>
</ul>
<p><strong>总而言之，多态就是同样的引用调用同样的方法却做了不同的事情</strong></p>
<h4 id="_2-多态的好处"> 2.多态的好处</h4>
<p><strong>1.可以把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程。</strong></p>
<p><strong>2.统一调用标准，一切向父类看齐。</strong></p>
<p><strong>3.提高了程序的扩展性和可维护性。</strong></p>
<h4 id="_3-多态转型"> 3.多态转型</h4>
<p><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="color:red;"><span style="color:red;">多态的转型一共分为两种：向上转型和向下转型</span></span></span></span></span></p>
<p><strong>向上转型：</strong></p>
<ul>
<li>多态本身就是一个向上转型的过程</li>
<li>使用格式：父类类型 变量名=new 子类类型()</li>
<li>适用场景：当不需要面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作</li>
</ul>
<p><strong>向下转型：</strong></p>
<ul>
<li>一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用类型转为子类引用各类型</li>
<li>使用格式：子类类型 变量名=（子类类型） 父类类型的变量</li>
<li>适用场景：当要使用子类特有功能时</li>
</ul>
<p><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="color:red;"><span style="color:red;">向下转型的注意事项：</span></span></span></span></span></p>
<ul>
<li>向下转型的前提是父类对象指向的是子类对象（也就是说，在向下转型之前，它得先向上转型）</li>
<li>向下转型只能转型为本类对象（比如学生类是不能转换成老师类的）。</li>
</ul>
<h4 id="_4-多态案例"> 4.多态案例</h4>
<div><pre><code><span>public</span> <span>class</span> test <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    	<span>People</span> p <span>=</span> <span>new</span> <span>Students</span><span>(</span><span>)</span><span>;</span>       <span>//父类引用指向子类对象</span>
    	p<span>.</span><span>id</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>class</span> <span>People</span><span>{</span>
    <span>public</span> <span>void</span> <span>id</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"人"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>class</span> <span>Students</span> <span>extends</span> <span>People</span><span>{</span>     <span>//继承</span>
    <span>public</span> <span>void</span> <span>id</span><span>(</span><span>)</span><span>{</span>              <span>//重写</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"学生"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>study</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"好好学习"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p><strong>这段代码运行后的结果是</strong><code>学生</code></p>
<p><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="color:red;"><span style="color:red;">当使用多态方式调用方法时，首先检查父类中是否有该方法，</span></span></span></span></span>
<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="color:red;"><span style="color:red;">如果没有，则编译错误；如果有，再去调用子类的同名方法。</span></span></span></span></span></p>
<p>比如我们在<code>p.id();</code>下一行加上<code>p.study();</code></p>
<div><pre><code><span>public</span> <span>class</span> test <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    	<span>People</span> p <span>=</span> <span>new</span> <span>Students</span><span>(</span><span>)</span><span>;</span>
    	p<span>.</span><span>id</span><span>(</span><span>)</span><span>;</span>
    	p<span>.</span><span>study</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>此时编译器会报study()方法没有定义的错误，其实这样写已经违反了多态的前提条件：要有方法重写。因为编译器在People类中找不到study()方法，所以就不满足多态的条件</strong></p>
<p><strong>如果要调用study()方法，就要用到上面讲的的向下转型来实现子类的特有功能</strong></p>
<div><pre><code><span>public</span> <span>class</span> test <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    	<span>People</span> p <span>=</span> <span>new</span> <span>Students</span><span>(</span><span>)</span><span>;</span>
    	p<span>.</span><span>id</span><span>(</span><span>)</span><span>;</span>
    	<span>Students</span> st <span>=</span> <span>(</span><span>Students</span><span>)</span> p<span>;</span>
    	st<span>.</span><span>study</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>class</span> <span>People</span><span>{</span>
    <span>public</span> <span>void</span> <span>id</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"人"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>class</span> <span>Students</span> <span>extends</span> <span>People</span><span>{</span>
    <span>public</span> <span>void</span> <span>id</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"学生"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>study</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"好好学习"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p><strong>接下来看一下完整的样例来帮助理解</strong></p>
<div><pre><code><span>public</span> <span>class</span> test <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    	<span>People</span> p1 <span>=</span> <span>new</span> <span>People</span><span>(</span><span>)</span><span>;</span>
    	<span>People</span> p2 <span>=</span> <span>new</span> <span>Students</span><span>(</span><span>)</span><span>;</span>
    	<span>People</span> p3 <span>=</span> <span>new</span> <span>Teachers</span><span>(</span><span>)</span><span>;</span>
    	p1<span>.</span><span>id</span><span>(</span><span>)</span><span>;</span>
    	p2<span>.</span><span>id</span><span>(</span><span>)</span><span>;</span>
    	<span>Students</span> st <span>=</span> <span>(</span><span>Students</span><span>)</span> p2<span>;</span>
    	st<span>.</span><span>study</span><span>(</span><span>)</span><span>;</span>
    	p3<span>.</span><span>id</span><span>(</span><span>)</span><span>;</span>
    	<span>Teachers</span> th <span>=</span> <span>(</span><span>Teachers</span><span>)</span> p3<span>;</span>
    	th<span>.</span><span>teach</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>class</span> <span>People</span><span>{</span>
    <span>public</span> <span>void</span> <span>id</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"人"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>class</span> <span>Students</span> <span>extends</span> <span>People</span><span>{</span>
    <span>public</span> <span>void</span> <span>id</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"学生"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>study</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"好好学习"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>class</span> <span>Teachers</span> <span>extends</span> <span>People</span><span>{</span>
    <span>public</span> <span>void</span> <span>id</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"老师"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>teach</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"认真授课"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p>这段代码最后输出的结果是</p>
<div><pre><code>人
学生
好好学习
老师
认真授课
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="组合"> 组合</h2>
<p>组合其实不难理解，就是将对象引用置于新类中即可。组合也是提高类的复用性的一种方式。如果你想让类具有更多的扩展功能，你需要记住一句话：<strong>多用组合，少用继承</strong>。</p>
<div><pre><code><span>public</span> <span>class</span> <span>SoccerPlayer</span> <span>{</span>

    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>Soccer</span> soccer<span>;</span>

<span>}</span>

<span>public</span> <span>class</span> <span>Soccer</span><span>{</span>

    <span>private</span> <span>String</span> soccerName<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>代码中<code>SoccerPlayer</code>引用了<code>Soccer</code>类，通过引用<code>Soccer</code>类来达到调用<code>Soccer</code>中的属性和方法。</p>
<p>组合和继承是有区别的，它们的主要区别如下：</p>
<table>
<thead>
<tr>
<th>特征</th>
<th>组合</th>
<th>继承</th>
</tr>
</thead>
<tbody>
<tr>
<td>关系</td>
<td>组合是一种 has - a的关系，可以理解为有一个</td>
<td>继承是一种 is - a的关系，可以理解为是一个</td>
</tr>
<tr>
<td>耦合性</td>
<td>组合的双方是一种松耦合的关系</td>
<td>继承双方紧耦合</td>
</tr>
<tr>
<td>是否具有多态</td>
<td>组合不具备多态和向上转型</td>
<td>继承是多态的继承，可以实现向上转型</td>
</tr>
<tr>
<td>时期</td>
<td>组合是运行期绑定</td>
<td>继承是编译期绑定</td>
</tr>
</tbody>
</table>
<h2 id="static"> static</h2>
<p>static 是 Java 中的关键字，它的意思是<code>静态的</code>，static可以用来修饰成员变量和方法，static用在没有创建对象的情况下调用 方法/变量</p>
<ul>
<li>用static声明的成员变量为静态成员变量，也称为类变量。类变量的生命周期与类相同，在整个应用程序执行周期都有效。</li>
</ul>
<div><pre><code><span>static</span> <span>String</span> name <span>=</span> <span>"Tryna"</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>使用static修饰的方法称为静态方法，静态方法能够直接使用<code>类名.方法名</code>进行调用。由于静态方法不依赖于任何对象就可以直接访问，因此对于静态方法来说，是没有this关键字的，实例变量都会有this关键字。<strong>在静态方法中不能访问类的非静态成员变量和非静态方法</strong>。</li>
</ul>
<div><pre><code><span>static</span> <span>void</span> <span>printMessage</span><span>(</span><span>)</span> <span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Hello World!"</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>static 除了修饰属性和方法外，还有<code>静态代码块</code>的功能，可用于类的初始化操作。进而提升程序的性能。</p>
<div><pre><code><span>public</span> <span>class</span> <span>StaticBlock</span> <span>{</span>
    <span>static</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Hello World!"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>由于静态代码块随着类的加载而执行，因此，很多时候会将只需要进行一次的初始化操作放在<code>static</code>代码块中执行。</p>
<h2 id="final"> final</h2>
<p>final 的意思是最后的、最终的，它可以修饰类、属性和方法</p>
<ul>
<li>final修饰类时，表明这个类不能被继承。final类中的成员变量可根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。</li>
<li>final修饰方法时，表名这个方法不能被任何子类重写，因此，如果只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final</li>
<li>final修饰变量分为两种情况，一种是修饰基本数据类型，表示数据类型的值不能被修改；一种是修饰引用类型，表示对其初始化之后便不能再让其指向另一个对象。</li>
</ul>
<h2 id="string-stringbuffer-和-stringbuilder-的区别是什么-string-为什么是不可变的"> String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</h2>
<p><strong>可变性</strong></p>
<p>final 关键字修饰的数组保存字符串并不是 String 不可变的根本原因，因为这个数组保存的字符串是可变的（final 修饰引用类型变量的情况）。</p>
<p>String 真正不可变有下面几点原因：</p>
<ul>
<li>1.保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法。</li>
<li>2.String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。</li>
</ul>
<p>StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，不过没有使用 final 和 private 关键字修饰，最关键的是这个 AbstractStringBuilder 类还提供了很多修改字符串的方法比如 append 方法。</p>
<div><pre><code> <span>abstract</span> <span>class</span> <span>AbstractStringBuilder</span> <span>implements</span> <span>Appendable</span><span>,</span> <span>CharSequence</span> <span>{</span>
    <span>char</span><span>[</span><span>]</span> value<span>;</span>
    <span>public</span> <span>AbstractStringBuilder</span> <span>append</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>str <span>==</span> <span>null</span><span>)</span>
            <span>return</span> <span>appendNull</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> len <span>=</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
        <span>ensureCapacityInternal</span><span>(</span>count <span>+</span> len<span>)</span><span>;</span>
        str<span>.</span><span>getChars</span><span>(</span><span>0</span><span>,</span> len<span>,</span> value<span>,</span> count<span>)</span><span>;</span>
        count <span>+=</span> len<span>;</span>
        <span>return</span> <span>this</span><span>;</span>
    <span>}</span>
  	<span>//...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><strong>线程安全性</strong></p>
<p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong></p>
<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<p>1.操作少量的数据: 适用 String
2.单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder
3.多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</p>
<h2 id="object-类的常见方法总结"> Object 类的常见方法总结</h2>
<p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p>
<div><pre><code><span>public</span> <span>final</span> <span>native</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>getClass</span><span>(</span><span>)</span><span>//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span>

<span>public</span> <span>native</span> <span>int</span> <span>hashCode</span><span>(</span><span>)</span> <span>//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span>
<span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> obj<span>)</span><span>//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span>

<span>protected</span> <span>native</span> <span>Object</span> <span>clone</span><span>(</span><span>)</span> <span>throws</span> <span>CloneNotSupportedException</span><span>//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span>

<span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span><span>//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span>

<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>notify</span><span>(</span><span>)</span><span>//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span>

<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>notifyAll</span><span>(</span><span>)</span><span>//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span>

<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>wait</span><span>(</span><span>long</span> timeout<span>)</span> <span>throws</span> <span>InterruptedException</span><span>//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span>

<span>public</span> <span>final</span> <span>void</span> <span>wait</span><span>(</span><span>long</span> timeout<span>,</span> <span>int</span> nanos<span>)</span> <span>throws</span> <span>InterruptedException</span><span>//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span>

<span>public</span> <span>final</span> <span>void</span> <span>wait</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span><span>//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span>

<span>protected</span> <span>void</span> <span>finalize</span><span>(</span><span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span> <span>}</span><span>//实例被垃圾回收器回收的时候触发的操作</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id="浅拷贝、深拷贝、引用拷贝"> 浅拷贝、深拷贝、引用拷贝</h2>
<ul>
<li><strong>浅拷贝：</strong> 浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>
<li><strong>深拷贝 ：</strong> 深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li>
<li><strong>引用拷贝：</strong> 简单来说，引用拷贝就是两个不同的引用指向同一个对象。</li>
</ul>
<p><img src="https://javaguide.cn/assets/img/shallow&amp;deep-copy.7ed0a9a3.png" alt="" loading="lazy"></p>
<h2 id="接口"> 接口</h2>
<p>接口相当于就是对外的一种约定和标准，这里拿操作系统举例子，为什么会有操作系统？就为了屏蔽软件的复杂性和硬件的简单性之间的差异，为软件提供统一的标准。</p>
<p>在 Java 语言中，接口是由<code>interface</code>关键字来表示的，比如我们可以向下面这样定义一个接口。</p>
<div><pre><code><span>public</span> <span>interface</span> <span>CxuanGoodJob</span><span>{</span><span>}</span>
</code></pre>
<div><span>1</span><br></div></div><p>比如我们定义了一个CxuanGoodJob的接口，然后你就可以在其内部定义cxuan做的好的那些事情，比如cxuan文章写得不错。</p>
<div><pre><code><span>public</span> <span>interface</span> <span>CxuanGoodJob</span><span>{</span>

    <span>void</span> <span>writeWell</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这里隐含了一些接口的特征：</p>
<ul>
<li><code>interface</code>接口是一个完全抽象的类，它不会提供任何方法的实现，只是会进行方法的定义。</li>
<li>接口中只能使用两种访问修饰符，一种是<code>public</code>，它对整个项目可见；一种是<code>default</code>缺省值，它只具有包访问权限。</li>
<li>接口只提供方法的定义，接口没有实现，但是接口可以被其他类实现。也就是说，实现接口的类要提供方法的实现，实现接口使用<code>implements</code>关键字来表示，一个接口可以有多个实现。</li>
</ul>
<div><pre><code><span>class</span> <span>CXuanWriteWell</span> <span>implements</span> <span>CxuanGoodJob</span><span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>writeWell</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"CXuan write Java is very well"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>
<li>接口不能被实例化，所以接口中不能有任何构造方法，你定义构造方法编译会出错。</li>
<li>接口的实现必须实现接口的全部方法，否则必须定义为抽象类。</li>
</ul>
<h2 id="抽象类"> 抽象类</h2>
<p>抽象类时一种抽象能力弱于接口的类，在 Java 中，抽象类使用<code>abstract</code>关键字来表示。如果把接口形容为狗这个物种，那么抽象类可以说是毛发是白色、小体的品种，而实现类可以是具体的类，比如说是博美、泰迪等。你可以像下面这样定义抽象类。</p>
<div><pre><code><span>public</span> <span>interface</span> <span>Dog</span><span>{</span>

    <span>void</span> <span>furColor</span><span>(</span><span>)</span><span>;</span>

<span>}</span>

<span>abstract</span> <span>class</span> <span>WhiteDog</span> <span>implements</span> <span>Dog</span><span>{</span>

    <span>public</span> <span>void</span> <span>furColor</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Fur is white"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>abstract</span> <span>void</span> <span>smallBody</span><span>(</span><span>)</span><span>;</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>在抽象类中，具有如下特征：</p>
<ul>
<li>如果一个类中有抽象方法，那么这个类一定是抽象类，也就是说，使用关键字<code>abstract</code>修饰的方法一定是抽象方法，具有抽象方法的类一定是抽象类。实现类方法中只有方法具体的实现。</li>
<li>抽象类中不一定只有抽象方法，抽象类中也可以有具体的方法，你可以自己去选择是否实现这些方法。</li>
<li>抽象类中的约束不像接口那么严格，你可以在抽象类中定义构造方法、抽象方法、普通属性、方法、静态属性和静态方法。</li>
<li>抽象类和接口一样不能被实例化，实例化只能实例化具体的类。</li>
</ul>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">项目主页</title>
    <id>https://vuepress-theme-hope-demo.mrhope.site/</id>
    <link href="https://vuepress-theme-hope-demo.mrhope.site/"/>
    <updated>2022-02-21T13:44:21.783Z</updated>
    <content type="html"><![CDATA[<h1 id="study"> study</h1>
<h4 id="介绍"> 介绍</h4>
<p>我是一名双非学校大三在读的学生，开这个仓库是因为自己想找到一份不错的工作，希望这个仓库可以起到督促自己学习的作用。本想着以博客的方式来记录这一切的，通过交流发现队友(我曾经是一名acm蒟蒻)用的是这种方式，我觉得挺好也就效仿了。</p>
<h4 id="内容参考"> 内容参考</h4>
<ol>
<li><a href="https://javaguide.cn/home/" target="_blank" rel="noopener noreferrer">JavaGuide</a></li>
<li><a href="https://www.r2coding.com/#/" target="_blank" rel="noopener noreferrer">Road 2 Coding</a></li>
<li><a href="https://leetcode-cn.com/problem-list/xb9nqhhg/" target="_blank" rel="noopener noreferrer">剑指Offer(第二版)</a></li>
<li><a href="https://leetcode-cn.com/problem-list/2cktkvj/" target="_blank" rel="noopener noreferrer">LeetCode 热题 HOT 100</a></li>
</ol>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
</feed>